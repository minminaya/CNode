package com.minminaya.data.model;

import java.util.List;

/**
 * Created by Niwa on 2017/5/14.
 */

public class TabModel {

    /**
     * success : true
     * data : [{"id":"58d0fb3517f61387400b7e15","author_id":"4f447c2f0a8abae26e01b27d","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/1ac00bee5abd7cc1d9a9435f861acba6.png\" alt=\"screenshot.png\"><\/p>\n<blockquote>\n<p>原文地址：<a href=\"https://zhuanlan.zhihu.com/p/25860846\">https://zhuanlan.zhihu.com/p/25860846<\/a><\/p>\n<\/blockquote>\n<hr>\n<p>时光如梭，转眼间 Egg.js 已经开源半年了，我们很荣幸地宣布，Egg.js 正式发布 1.0 版本。<\/p>\n<ul>\n<li>官网传送门：<a href=\"https://eggjs.org\">https://eggjs.org<\/a><\/li>\n<li>GitHub：<a href=\"https://github.com/eggjs/egg\">https://github.com/eggjs/egg<\/a><\/li>\n<li>Egg.js 英文文档：与 SwiftGG 翻译组强强联合，中译英的小伙伴招募中，如果你有兴趣，请试译 这篇文章 ，并注明你的 qq 号，发送给 SwiftGG 的同学邮箱(<a href=\"mailto:1030041592@qq.com\">1030041592@qq.com<\/a>)。期待你的加入！<\/li>\n<\/ul>\n<h2>特点<\/h2>\n<ul>\n<li><strong>『企业级的 Node.js Web 基础框架』<\/strong>，寓意 - 孕育新生。<\/li>\n<li>业界领先的 <strong>『微内核 + 插件机制』<\/strong>，专为团队架构师量身打造的 <strong>『框架定制』<\/strong> 能力。<\/li>\n<li>内建的安全机制与多进程管理模型。<\/li>\n<li>高可用，高质量，严格遵循 Semver 规则，测试覆盖率 100%（travis/appveyor)。<\/li>\n<li>同时支持 koa 1.x 和 2.x 生态，支持 ES 2017 Async Await。<\/li>\n<li>沉淀自阿里各行各业不同领域最佳实践的插件，涵盖了常见的业务开发场景，稳定支撑了 15 和 16 年天猫双11大促，顶级流量压力。<\/li>\n<li>渐进式，极具伸缩性，既适合个人小项目快速开发，也适合企业级的团队开发协作。<\/li>\n<\/ul>\n<blockquote>\n<p>更详细的特点，以及 Node.js 在阿里的定位，可以参见： <a href=\"https://www.zhihu.com/question/50526101/answer/144952130\">如何评价阿里开源的企业级 Node.js 框架 egg？<\/a><\/p>\n<\/blockquote>\n<h2>里程碑<\/h2>\n<ul>\n<li>2013 年蚂蚁的 chair 框架，可视为 Egg.js 前身。<\/li>\n<li>2015 年 11 月，在苏千的召集下，阿里各 BU 的前端骨干齐聚黄龙，闭门共建一周。<\/li>\n<li>2016 年初，各 BU 的基础 Web 框架完成升级，在同一套规范的基础上进行差异化定制。<\/li>\n<li>2016 年中，成为阿里 Node.js 基建，广泛使用在绝大部分阿里的前端 Node.js 应用。<\/li>\n<li>2016 年 09 月，在 <a href=\"http://2016.jsconf.cn/\">JSConf China 2016<\/a> 上亮相并宣布开源。<\/li>\n<li>2017 年初，经过一周的<a href=\"https://cnodejs.org/topic/5870e9da04dcf9a706a745f0\">闭关直播写文档<\/a>，期待已久的 <a href=\"https://eggjs.org/\">官方文档<\/a> 诚意登场，足足近 30 篇。<\/li>\n<li>2017年 02 月，知乎问答：<a href=\"https://www.zhihu.com/question/50526101/answer/144952130\">如何评价阿里开源的企业级 Node.js 框架 egg？<\/a><\/li>\n<li>2017 年 02 月第 2 周，上了 <strong>GitHub Trending<\/strong> 周榜第三，Star 数增加 1k 多。<\/li>\n<li>2017 年 03 月 21 日，Egg.js 正式发布 1.0.0 。<\/li>\n<\/ul>\n<h2>成就<\/h2>\n<ul>\n<li>截止到今天，2250+ Star，50+ 插件，10+ 核心开发者，30+ 贡献者。<\/li>\n<li>GitHub Trending 周榜第三，并上了 Node Weekly 周刊。<\/li>\n<li>官网 UV 日均 300+ 。<\/li>\n<\/ul>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2a69766ae55cab517418e7b2f004d9b9.png\" alt=\"screenshot.png\"><\/p>\n<ul>\n<li>Node TSC Director - Rod Vagg 在 Twitter 上关注并转发。<\/li>\n<\/ul>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/42f3483f8c7b9a39678958816f477ae2.png\" alt=\"screenshot.png\"><\/p>\n<h2>感言<\/h2>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6461618ea8944a1fb5ada1db8aeb7de7.png\" alt=\"screenshot.png\"><\/p>\n<h2>规划<\/h2>\n<ul>\n<li>Egg.js 英文文档翻译，欢迎加入 <a href=\"http://swift.gg/\">SwiftGG 翻译组<\/a> 发起的 <a href=\"https://github.com/eggjs/egg/issues/363\">Egg 文档翻译项目<\/a>。<\/li>\n<li>继续完善文档，沉淀最佳实践，并帮助社区产出更多的插件和上层框架。<\/li>\n<li>Node.js 8 LTS 发布后，底层将无缝升级到 Koa<a href=\"/user/2\">@2<\/a> 。<\/li>\n<\/ul>\n<\/div>","title":"Egg.js 1.0.0 正式发布 - 企业级 Node.js 框架","last_reply_at":"2017-05-13T15:29:10.915Z","good":false,"top":true,"reply_count":135,"visit_count":24361,"create_at":"2017-03-21T10:06:45.487Z","author":{"loginname":"atian25","avatar_url":"https://avatars.githubusercontent.com/u/227713?v=3&s=120"}},{"id":"58e607b0ddee72813eb22323","author_id":"4efc278525fa69ac6900000f","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/cnpm/cnpm\">cnpm cli<\/a> 的 install 速度已经是目前最快的一种 npm installer 了，最近 npm registry 推出了一种全新的 registry api 格式: <a href=\"https://github.com/npm/registry/blob/master/docs/responses/package-metadata.md#abbreviated-metadata-format\">Abbreviated metadata format<\/a>，它可以大大减少install 过程中的网络请求数据大小，于是我们也在第一时间实现到 npminstall 中了。<\/p>\n<p>为了更加平滑地更新过渡，我们计划使用2周时间来做beta测试，然后没什么大问题之后，将会发布正式版本的 cnpm<a href=\"/user/5\">@5<\/a> 。<\/p>\n<h2>尝鲜者来<\/h2>\n<p>直接通过 beta 版本可以参与测试。<\/p>\n<pre class=\"prettyprint language-bash\"><code>$ cnpm install cnpm@beta -g \n<\/code><\/pre><h2>问题反馈<\/h2>\n<p>遇到任何问题，请直接回复到 <a href=\"https://github.com/cnpm/cnpm/pull/187\">https://github.com/cnpm/cnpm/pull/187<\/a> 。<\/p>\n<h2>回滚<\/h2>\n<p>一键回滚到稳定版本。<\/p>\n<pre class=\"prettyprint language-bash\"><code>$ cnpm install cnpm -g\n<\/code><\/pre><\/div>","title":"cnpm@5 beta 测试招募","last_reply_at":"2017-05-13T09:39:49.570Z","good":false,"top":true,"reply_count":99,"visit_count":15473,"create_at":"2017-04-06T09:17:36.511Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars3.githubusercontent.com/u/156269?v=3&s=120"}},{"id":"58ad76db7872ea0864fedfcc","author_id":"51f0f267f4963ade0e08f503","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FlwW5i2h_UuKpnBXXvD3AqyrwjHP\" alt=\"untitled4.png\"><\/p>\n<h1>饿了么大前端 Node.js 进阶教程<\/h1>\n<p>因为 2016 年面试了很多做 Node.js 的同学，发现大部分做 Node 的同学都是前端转过来的，对后端的知识大多一片空白。所以很难招到比较好的 Node.js 服务端程序员（注意，不是全栈）。<\/p>\n<p>于是出于我们一贯的开源与分享精神，我们筹备了这个名字叫《如何通过饿了么 Node.js 面试》的开源的 Node.js 进阶教程。<\/p>\n<p>github 仓库地址：<a href=\"https://github.com/ElemeFE/node-interview\">https://github.com/ElemeFE/node-interview<\/a><\/p>\n<h3>导读<\/h3>\n<p>本教程包含 2~3 年经验的 Node.js 服务端需要知道的知识点。<\/p>\n<p>需要注意的是, 并不适用于零基础的同学, 你需要有一定的 JavaScript/Node.js 基础, 并且有一定的工作经验. 另外本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分.<\/p>\n<p>稳重将一些常见的问题划分归类, 每类标明涵盖的一些<code>覆盖点<\/code>, 并且列举几个<code>常见问题<\/code>, 通常这些问题都是 2~3 年工作经验需要了解或者面对的. 如果你对某类问题感兴趣, 或者想知道其中列举问题的答案, 可以通过该类下方的 <code>阅读更多<\/code> 查看更多的内容.<\/p>\n<p>整体上大纲列举的并不是很全面, 细节上覆盖率不高, 很多讨论只是点到即止, 希望大家带着问题去思考.<\/p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md\">Js 基础问题<\/a><\/h2>\n<blockquote>\n<p>与前端 Js 不同, 后端是直面服务器的, 更加偏向内存方面.<\/p>\n<\/blockquote>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD\"><code>[Basic]<\/code> 类型判断<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><code>[Basic]<\/code> 作用域<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\"><code>[Basic]<\/code> 引用传递<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE\"><code>[Basic]<\/code> 内存释放<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#es6-%E6%96%B0%E7%89%B9%E6%80%A7\"><code>[Basic]<\/code> ES6 新特性<\/a><\/li>\n<\/ul>\n<h3>常见问题<\/h3>\n<ul>\n<li>js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#q-value\">[more]<\/a><\/li>\n<li>js 中， 0.1 + 0.2 === 0.3 是否为 true ? 在不知道浮点数位数时应该怎样判断两个浮点数之和与第三数是否相等？<\/li>\n<li>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#q-const\">[more]<\/a><\/li>\n<li>JavaScript 中不同类型以及不同环境下变量的内存都是何时释放? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md#q-mem\">[more]<\/a><\/li>\n<\/ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/js-basic.md\">阅读更多<\/a><\/p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md\">模块<\/a><\/h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6\"><code>[Basic]<\/code> 模块机制<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#%E7%83%AD%E6%9B%B4%E6%96%B0\"><code>[Basic]<\/code> 热更新<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#%E4%B8%8A%E4%B8%8B%E6%96%87\"><code>[Basic]<\/code> 上下文<\/a><\/li>\n<\/ul>\n<h3>常见问题<\/h3>\n<ul>\n<li>a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#q-loop\">[more]<\/a><\/li>\n<li>如果 a.js require 了 b.js, 那么在 b 中定义全局变量 <code>t = 111<\/code> 能否在 a 中直接打印出来? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#q-global\">[more]<\/a><\/li>\n<li>如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md#q-hot\">[more]<\/a><\/li>\n<\/ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/module.md\">阅读更多<\/a><\/p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md\">事件/异步<\/a><\/h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#promise\"><code>[Basic]<\/code> Promise<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#events\"><code>[Doc]<\/code> Events (事件)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#timers\"><code>[Doc]<\/code> Timers (定时器)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5\"><code>[Point]<\/code> 阻塞/异步<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91\"><code>[Point]<\/code> 并行/并发<\/a><\/li>\n<\/ul>\n<h3>常见问题<\/h3>\n<ul>\n<li>Promise 中 .then 的第二参数与 .catch 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-1\">[more]<\/a><\/li>\n<li>Eventemitter 的 emit 是同步还是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-2\">[more]<\/a><\/li>\n<li>如何判断接口是否异步? 是否只要有回调函数就是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-3\">[more]<\/a><\/li>\n<li>nextTick, setTimeout 以及 setImmediate 三者有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-4\">[more]<\/a><\/li>\n<li>如何实现一个 sleep 函数? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-5\">[more]<\/a><\/li>\n<li>如何实现一个异步的 reduce? (注:不是异步完了之后同步 reduce) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md#q-6\">[more]<\/a><\/li>\n<\/ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/event-async.md\">阅读更多<\/a><\/p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md\">进程<\/a><\/h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#process\"><code>[Doc]<\/code> Process (进程)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#child-process\"><code>[Doc]<\/code> Child Processes (子进程)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#cluster\"><code>[Doc]<\/code> Cluster (集群)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><code>[Basic]<\/code> 进程间通信<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\"><code>[Basic]<\/code> 守护进程<\/a><\/li>\n<\/ul>\n<h3>常见问题<\/h3>\n<ul>\n<li>进程的当前工作目录是什么? 有什么作用? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#q-cwd\">[more]<\/a><\/li>\n<li>child_process.fork 与 POSIX 的 fork 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#q-fork\">[more]<\/a><\/li>\n<li>父进程或子进程的死亡是否会影响对方? 什么是孤儿进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#q-child\">[more]<\/a><\/li>\n<li>cluster 是如何保证负载均衡的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#how-it-works\">[more]<\/a><\/li>\n<li>什么是守护进程? 如何实现守护进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\">[more]<\/a><\/li>\n<\/ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/process.md\">阅读更多<\/a><\/p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md\">IO<\/a><\/h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#buffer\"><code>[Doc]<\/code> Buffer<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#string-decoder\"><code>[Doc]<\/code> String Decoder (字符串解码)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#stream\"><code>[Doc]<\/code> Stream (流)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#console\"><code>[Doc]<\/code> Console (控制台)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#file\"><code>[Doc]<\/code> File System (文件系统)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#readline\"><code>[Doc]<\/code> Readline<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#repl\"><code>[Doc]<\/code> REPL<\/a><\/li>\n<\/ul>\n<h3>常见问题<\/h3>\n<ul>\n<li>Buffer 一般用于处理什么数据? 其长度能否动态变化? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#buffer\">[more]<\/a><\/li>\n<li>Stream 的 highWaterMark 与 drain 事件是什么? 二者之间的关系是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#%E7%BC%93%E5%86%B2%E5%8C%BA\">[more]<\/a><\/li>\n<li>Stream 的 pipe 的作用是? 在 pipe 的过程中数据是引用传递还是拷贝传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#pipe\">[more]<\/a><\/li>\n<li>什么是文件描述符? 输入流/输出流/错误流是什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#file\">[more]<\/a><\/li>\n<li>console.log 是同步还是异步? 如何实现一个 console.log? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#console\">[more]<\/a><\/li>\n<li>如何同步的获取用户的输入?  <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E7%9A%84%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5\">[more]<\/a><\/li>\n<li>Readline 是如何实现的? (有思路即可) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md#readline\">[more]<\/a><\/li>\n<\/ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/io.md\">阅读更多<\/a><\/p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md\">Network<\/a><\/h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#net\"><code>[Doc]<\/code> Net (网络)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#udp\"><code>[Doc]<\/code> UDP/Datagram<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#http\"><code>[Doc]<\/code> HTTP<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#dns\"><code>[Doc]<\/code> DNS (域名服务器)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#zlib\"><code>[Doc]<\/code> ZLIB (压缩)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#rpc\"><code>[Point]<\/code> RPC<\/a><\/li>\n<\/ul>\n<h3>常见问题<\/h3>\n<ul>\n<li>cookie 与 session 的区别? 服务端如何清除 cookie? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-cookie-session\">[more]<\/a><\/li>\n<li>HTTP 协议中的 POST 和 PUT 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-post-put\">[more]<\/a><\/li>\n<li>什么是跨域请求? 如何允许跨域? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-cors\">[more]<\/a><\/li>\n<li>TCP/UDP 的区别? TCP 粘包是怎么回事，如何处理? UDP 有粘包吗? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-tcp-udp\">[more]<\/a><\/li>\n<li><code>TIME_WAIT<\/code> 是什么情况? 出现过多的 <code>TIME_WAIT<\/code> 可能是什么原因? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#q-time-wait\">[more]<\/a><\/li>\n<li>ECONNRESET 是什么错误? 如何复现这个错误?<\/li>\n<li>socket hang up 是什么意思? 可能在什么情况下出现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md#socket-hang-up\">[more]<\/a><\/li>\n<li>hosts 文件是什么? 什么叫 DNS 本地解析?<\/li>\n<li>列举几个提高网络传输速度的办法?<\/li>\n<\/ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/network.md\">阅读更多<\/a><\/p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md\">OS<\/a><\/h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#tty\"><code>[Doc]<\/code> TTY<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#os\"><code>[Doc]<\/code> OS (操作系统)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#path\"><code>[Doc]<\/code> Path<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0\"><code>[Doc]<\/code> 命令行参数<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#%E8%B4%9F%E8%BD%BD\"><code>[Basic]<\/code> 负载<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#checklist\"><code>[Point]<\/code> CheckList<\/a><\/li>\n<\/ul>\n<h3>常见问题<\/h3>\n<ul>\n<li>什么是 TTY? 如何判断是否处于 TTY 环境? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#tty\">[more]<\/a><\/li>\n<li>不同操作系统的换行符 (EOL) 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#os\">[more]<\/a><\/li>\n<li>服务器负载是什么概念? 如何查看负载? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#%E8%B4%9F%E8%BD%BD\">[more]<\/a><\/li>\n<li>ulimit 是用来干什么的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md#ulimit\">[more]<\/a><\/li>\n<\/ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/os.md\">阅读更多<\/a><\/p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md\">错误处理/调试/优化<\/a><\/h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#errors\"><code>[Doc]<\/code> Errors (异常)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#domain\"><code>[Doc]<\/code> Domain (域)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#debugger\"><code>[Doc]<\/code> Debugger (调试器)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#c-c++-addon\"><code>[Doc]<\/code> C/C++ 插件<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#v8\"><code>[Doc]<\/code> V8<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\"><code>[Point]<\/code> 内存快照<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#cpu-profiling\"><code>[Point]<\/code> CPU profiling<\/a><\/li>\n<\/ul>\n<h3>常见问题<\/h3>\n<ul>\n<li>怎么处理未预料的出错? 用 try/catch ，domains 还是其它什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#q-handle-error\">[more]<\/a><\/li>\n<li>什么是 <code>uncaughtException<\/code> 事件? 一般在什么情况下使用该事件? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#uncaughtexception\">[more]<\/a><\/li>\n<li>domain 的原理是? 为什么要弃用 domain? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#domain\">[more]<\/a><\/li>\n<li>什么是防御性编程? 与其相对的 let it crash 又是什么?<\/li>\n<li>为什么要在 cb 的第一参数传 error? 为什么有的 cb 第一个参数不是 error, 例如 http.createServer?<\/li>\n<li>为什么有些异常没法根据报错信息定位到代码调用? 如何准确的定位一个异常? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#%E9%94%99%E8%AF%AF%E6%A0%88%E4%B8%A2%E5%A4%B1\">[more]<\/a><\/li>\n<li>内存泄漏通常由哪些原因导致? 如何分析以及定位内存泄漏? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\">[more]<\/a><\/li>\n<\/ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/error.md\">阅读更多<\/a><\/p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md\">测试<\/a><\/h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\"><code>[Basic]<\/code> 测试方法<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\"><code>[Basic]<\/code> 单元测试<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95\"><code>[Basic]<\/code> 集成测试<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95\"><code>[Basic]<\/code> 基准测试<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95\"><code>[Basic]<\/code> 压力测试<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#assert\"><code>[Doc]<\/code> Assert (断言)<\/a><\/li>\n<\/ul>\n<h3>常见问题<\/h3>\n<ul>\n<li>为什么要写测试? 写测试是否会拖累开发进度?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#q-why-write-test\">[more]<\/a><\/li>\n<li>单元测试的单元是指什么? 什么是覆盖率?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">[more]<\/a><\/li>\n<li>测试是如何保证业务逻辑中不会出现死循环的?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#q-death-loop\">[more]<\/a><\/li>\n<li>mock 是什么? 一般在什么情况下 mock?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md#mock\">[more]<\/a><\/li>\n<\/ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/test.md\">阅读更多<\/a><\/p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md\">util<\/a><\/h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#url\"><code>[Doc]<\/code> URL<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#query-strings\"><code>[Doc]<\/code> Query Strings (查询字符串)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#util-1\"><code>[Doc]<\/code> Utilities (实用函数)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><code>[Basic]<\/code> 正则表达式<\/a><\/li>\n<\/ul>\n<h3>常见问题<\/h3>\n<ul>\n<li>HTTP 如何通过 GET 方法 (URL) 传递 let arr = [1,2,3,4] 给服务器? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#get-param\">[more]<\/a><\/li>\n<li>Node.js 中继承 (util.inherits) 的实现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#utilinherits\">[more]<\/a><\/li>\n<li>如何递归获取某个文件夹下所有的文件名? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md#q-traversal\">[more]<\/a><\/li>\n<\/ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/util.md\">阅读更多<\/a><\/p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md\">存储<\/a><\/h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#mysql\"><code>[Point]<\/code> Mysql<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#mongodb\"><code>[Point]<\/code> Mongodb<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#replication\"><code>[Point]<\/code> Replication<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\"><code>[Point]<\/code> 数据一致性<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#%E7%BC%93%E5%AD%98\"><code>[Point]<\/code> 缓存<\/a><\/li>\n<\/ul>\n<h3>常见问题<\/h3>\n<ul>\n<li>备份数据库与 M/S, M/M 等部署方式的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#replication\">[more]<\/a><\/li>\n<li>索引有什么用，大致原理是什么? 设计索引有什么注意点? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#%E7%B4%A2%E5%BC%95\">[more]<\/a><\/li>\n<li>Monogdb 连接问题(超时/断开等)有可能是什么问题导致的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#Mongodb\">[more]<\/a><\/li>\n<li>什么情况下数据会出现脏数据? 如何避免? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\">[more]<\/a><\/li>\n<li>redis 与 memcached 的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md#%E7%BC%93%E5%AD%98\">[more]<\/a><\/li>\n<\/ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/storage.md\">阅读更多<\/a><\/p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md\">安全<\/a><\/h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#crypto\"><code>[Doc]<\/code> Crypto (加密)<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#tlsssl\"><code>[Doc]<\/code> TLS/SSL<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#https\"><code>[Doc]<\/code> HTTPS<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#xss\"><code>[Point]<\/code> XSS<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#csrf\"><code>[Point]<\/code> CSRF<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\"><code>[Point]<\/code> 中间人攻击<\/a><\/li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#sqlnosql-%E6%B3%A8%E5%85%A5\"><code>[Point]<\/code> Sql/Nosql 注入<\/a><\/li>\n<\/ul>\n<h3>常见问题<\/h3>\n<ul>\n<li>加密是如何保证用户密码的安全性? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#crypto\">[more]<\/a><\/li>\n<li>TLS 与 SSL 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#tlsssl\">[more]<\/a><\/li>\n<li>HTTPS 能否被劫持? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#https\">[more]<\/a><\/li>\n<li>XSS 攻击是什么? 有什么危害? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#xss\">[more]<\/a><\/li>\n<li>过滤 Html 标签能否防止 XSS? 请列举不能的情况? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#xss\">[more]<\/a><\/li>\n<li>CSRF 是什么? 如何防范? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#csrf\">[more]<\/a><\/li>\n<li>如何避免中间人攻击? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\">[more]<\/a><\/li>\n<\/ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/security.md\">阅读更多<\/a><\/p>\n<h2>最后<\/h2>\n<p>目前 repo 处于施工现场的情况，如果发现问题欢迎在 <a href=\"https://github.com/ElemeFE/node-interview/issues\">issues<\/a> 中指出。如果有比较好的<code>问题/知识点/指正<\/code>，也欢迎提 PR。<\/p>\n<p>另外关于 <code>Js 基础<\/code> 是个比较大的话题，在本教程不会很细致深入的讨论，更多的是列出一些重要或者更服务端更相关的地方，所以如果你拿着《JavaScript 权威指南》给教程提 PR 可能不会采纳。本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分。<\/p>\n<\/div>","title":"饿了么大前端 Node.js 进阶教程","last_reply_at":"2017-05-13T09:37:56.824Z","good":true,"top":true,"reply_count":126,"visit_count":43062,"create_at":"2017-02-22T11:32:43.547Z","author":{"loginname":"lellansin","avatar_url":"https://avatars1.githubusercontent.com/u/2081487?v=3&s=120"}},{"id":"58eee565a92d341e48cfe7fc","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><h1>2017，我们来聊聊 Node.js<\/h1>\n<h2>版本帝？<\/h2>\n<p>Chrome浏览器已经蹦到57版本了，是名副其实的版本帝，作为兄弟的Node.js也一样，1.0之前等了6年，而从1.0到8.0，只用了2年时间，这世界到底怎么了？<\/p>\n<p>我们就数一下<\/p>\n<ul>\n<li>从v0.1到0.12用了6年<\/li>\n<li>2015-01-14发布了v1.0.0版本（io.js）<\/li>\n<li>2.x（io.js）<\/li>\n<li>3.x（io.js）<\/li>\n<li>2015年09月Node.js基金会已发布Node.js V4.0版 与io.js合并后的第一个版本<\/li>\n<li>2015年10月Node.jsv4.2.0将是首个lts长期支持版本<\/li>\n<li>2016年底发布到4.2.4 &amp;&amp; 5.4.0<\/li>\n<li>2016年3月20日v4.4.0 LTS（长期支持版本）和v5.9.0 Stable（稳定版本）<\/li>\n<li>2016 年底 v6.0 支持95%以上的es6特性 ， v7.0通过flag支持async函数，99%的es6特性<\/li>\n<li>2017年2月发布v7.6版本，可以不通过flag使用async函数<\/li>\n<\/ul>\n<p><img src=\"//dn-cnode.qbox.me/Fv8fvViUeOJpBlOWYzBo1txRUhdN\" alt=\"lts-schedule.png\"><\/p>\n<p>整体来说趋于稳定<\/p>\n<ul>\n<li>成立了Node.js基金会，能够让Node.js在未来有更好的开源社区支持<\/li>\n<li>发布了LTS版本，意味着api稳定<\/li>\n<li>快速发版本，很多人吐槽这个，其实换个角度看，这也是社区活跃的一个体现，但如果大家真的看CHANGELOG，其实都是小改进，而且是边边角角的改进，也就是说Node.js的core（核心）已经非常稳定了，可以大规模使用<\/li>\n<\/ul>\n<h2>已无性能优势？<\/h2>\n<p>Node.js在2009年横空出世，可以说是纯异步获得高性能的功劳。所有语言几乎没有能够和它相比的，比如Java、PHP、Ruby都被啪啪的打脸。但是山一程，水一程，福祸相依，因为性能太出众，导致很多语言、编程模型上有更多探索，比如go语言产生、php里的swolo和vm改进等，大家似乎都以不支持异步为耻辱。后来的故事大家都知道了，性能都提到非常高，c10问题已经没人再考虑，只是大家实现早晚而产生的性能差距而已。<\/p>\n<blockquote>\n<p>编程语言的性能趋于一样的极限，所以剩下的选择，只有喜好<\/p>\n<\/blockquote>\n<p>那么在这种情况下，Node.js还有优势么？<\/p>\n<ul>\n<li>实现成本：Node.js除了异步流程控制稍复杂外，其他的都非常简单，比如写法，你可以面向过程、面向对象、函数式，根据自己的解决选择就好了。不要因为它现在变化快，就觉得自己跟不上潮流。尤其是后端程序员转Node.js几乎是2周以内的成本，某些语言光熟悉语法习惯也不止2周吧？<\/li>\n<li>调优成本：Node.js即使不优化，它的性能也非常好，如果优化，也比其他语言更简单<\/li>\n<li>学习成本：是否必须用，如果是必须要用，那就少学一样是一样，人生有限，不能都花在写hello world上。我想问，大前端离得开js么？<\/li>\n<\/ul>\n<blockquote>\n<p>误读：Node.js已无性能优势，它现在最强大的是基于npm的生态<\/p>\n<\/blockquote>\n<p>上面是成本上的比较，其实大家把关注点都转移到基于npm的生态上，截止2017年2月，在npm上有超过45万个模块，秒杀无数。npm是所有的开源的包管理里最强大的，我们说更了不起的Node.js，其实npm居功甚伟，后面会有独立的章节进行阐述。<\/p>\n<p>来自<a href=\"http://www.modulecounts.com/\">www.modulecounts.com<\/a>的各个包管理模块梳理的比较<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FjmazMxffKETUdl9-NVoSqLB-DyT\" alt=\"Screen Shot 2017-04-04 at 21.02.41.png\">\nnpm生态是Node的优势不假，可是说\u201cNode.js没有性能优势\u201d真的对么？这其实就是误读，Node.js的性能依然很好呀，而且它有npm极其强大的生态，可谓性能与生态双剑合璧，你说你死不死？<\/p>\n<h2>异步和回调地狱？<\/h2>\n<blockquote>\n<p>天生异步，败也异步，成也异步<\/p>\n<\/blockquote>\n<p>正因为异步导致了api设计方式只能采用error-first风格的回调，于是大家硬生生的把callback写成了callback hell。于是各种黑粉就冒出来，无非是一些浅尝辄止之辈。但也正因为回调地狱是最差实践，所以大家才不得不求变，于是thunk、promise等纷沓而至。虽然Promise/A+不完美，但对于解决回调地狱是足够的了。而且随着ES6等规范实现，引入generator、co等，让异步越来越近于同步。当async函数落地的时候，Node已经站在了同C#、Python一样的高度上，大家还有什么理由黑呢？<\/p>\n<p>本小节先科普一下异步流程里的各种概念，后面会有独立章节进行详细讲解<\/p>\n<table>\n<thead>\n<tr>\n<th>名称<\/th>\n<th>说明<\/th>\n<th><\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>callback<\/td>\n<td>Node.js API天生就是这样的<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>thunk<\/td>\n<td>参数的求值策略<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>promise<\/td>\n<td>最开始是Promise/A+规范，随后成为ES6标准<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>generator<\/td>\n<td>ES6种的生成器，用于计算，但tj想用做流程控制<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>co<\/td>\n<td>generator用起来非常麻烦，故而tj写了co这个generator生成器，用法更简单<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>async函数<\/td>\n<td>原本计划进入es7规范，结果差一点，但好在v8实现了，所以node 7就可以使用，无须等es7规范落地<\/td>\n<td><\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<blockquote>\n<p>有时，将一件事儿做到极致，也许能有另一种天地<\/p>\n<\/blockquote>\n<h2>应用场景<\/h2>\n<p>MEAN是一个Javascript平台的现代Web开发框架总称，它是MongoDB + Express +AngularJS + NodeJS 四个框架的第一个字母组合。它与传统LAMP一样是一种全套开发工具的简称。在2014和2015年喜欢讲这个，并且还有MEAN.js等框架，但今天已经过时，Node.js有了更多的应用场景。<\/p>\n<p>《Node.js in action》一书里说，Node所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为Node自身在I/O上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。<\/p>\n<p>这话不假，但在今天来看，DIRT还是范围小了。其实DIRT本质上说的I/O处理的都算，但随着大前端的发展，Node.js已经不再只是I/O处理相关，而是更加的\u201cNode\u201d！<\/p>\n<p>这里给出Node.js的若干使用场景<\/p>\n<ul>\n<li>网站（如express/koa等）<\/li>\n<li>im即时聊天(<a href=\"http://socket.io\">socket.io<\/a>)<\/li>\n<li>api（移动端，pc，h5）<\/li>\n<li>HTTP Proxy（淘宝、Qunar、腾讯、百度都有）<\/li>\n<li>前端构建工具(grunt/gulp/bower/webpack/fis3\u2026)<\/li>\n<li>写操作系统（NodeOS）<\/li>\n<li>跨平台打包工具（PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的cordova，即老的Phonegap，还有更加有名的一站式开发框架ionicframework）<\/li>\n<li>命令行工具（比如cordova、shell.js）<\/li>\n<li>反向代理（比如anyproxy，node-http-proxy）<\/li>\n<li>编辑器Atom、VSCode等<\/li>\n<\/ul>\n<p>可以说目前大家能够看到的、用到的软件都有Node.js身影，当下最流行的软件写法也大都是基于Node.js的，比如PC客户端<a href=\"https://github.com/luin/medis\">luin/medis<\/a>采用electron打包，写法采用React+Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js的应用场景会更加的广泛。更多参见<a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs<\/a>。<\/p>\n<h3>Web框架<\/h3>\n<p>演进时间线大致如下：<\/p>\n<ul>\n<li>2010年tj写的Express<\/li>\n<li>2011年Derby.js开始开发，8月5日，WalmartLabs的一位成员Eran Hammer提交了Hapi的第一次commit。Hapi原本是Postmile的一部分，并且最开始是基于Express构建的。后来它发展成自己自己的框架，<\/li>\n<li>2012年1月21日，专注于rest api的restify发布1.0版本，同构的meteor开始投入开发，最像rails的sails也开始了开发<\/li>\n<li>2013年tj开始玩generator，编写co这个generator执行器，并开始了Koa。2013 年下半年李成银开始ThinkJS，参考ThinkPHP<\/li>\n<li>2014年，4月9日，express发布4.0，进入4.x时代持续到今天，MEAN.js开始随着MEAN架构的提出开始开发，意图大一统，另外total.js开始，最像PHP\u2019s Laravel 或 Python\u2019s Django 或 <a href=\"http://ASP.NET\">ASP.NET<\/a> MVC的框架<\/li>\n<li>2015年8月22日， 下一代Web框架Koa发布1.0，可以在node 0.12下面，通过co + generator实现同步逻辑，那时候co还是基于thunkfy的，2015.10.30 ThinkJS发布了Es2015+ 特性开发的v 2.0版本<\/li>\n<li>2016 年 09 月，蚂蚁金服的eggjs，在 JSConf China 2016 上亮相并宣布开源<\/li>\n<li>2017年2月，下一代Web框架Koa发布2.0<\/li>\n<\/ul>\n<p>我们可以根据框架的特性进行分类<\/p>\n<table>\n<thead>\n<tr>\n<th>框架名称<\/th>\n<th>特性<\/th>\n<th>点评<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>Express<\/td>\n<td>简单、实用，路由中间件等五脏俱全<\/td>\n<td>最著名的Web框架<\/td>\n<\/tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor<\/td>\n<td>同构<\/td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高<\/td>\n<\/tr>\n<tr>\n<td>Sails、Total<\/td>\n<td>面向其他语言，Ruby、PHP等<\/td>\n<td>借鉴业界优秀实现，也是Node.js成熟的一个标志<\/td>\n<\/tr>\n<tr>\n<td>MEAN.js<\/td>\n<td>面向架构<\/td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点<\/td>\n<\/tr>\n<tr>\n<td>Hapi和Restfy<\/td>\n<td>面向Api &amp;&amp; 微服务<\/td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器<\/td>\n<\/tr>\n<tr>\n<td>ThinkJS<\/td>\n<td>面向新特性<\/td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右<\/td>\n<\/tr>\n<tr>\n<td>Koa<\/td>\n<td>专注于异步流程改进<\/td>\n<td>下一代Web框架<\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<p>对于框架选型<\/p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置<\/li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定<\/li>\n<li>出现问题的时候，有人能Cover的住，Node.js虽然8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度<\/li>\n<\/ul>\n<blockquote>\n<p>个人学习求新，企业架构求稳，无非喜好与场景而已<\/p>\n<\/blockquote>\n<p>我猜大家能够想到的场景，大约如下<\/p>\n<ul>\n<li>前端工具，比如gulp、grunt、webpack等<\/li>\n<li>服务器，做类似于Java、PHP的事儿<\/li>\n<\/ul>\n<p>如果只是做这些，和Java、PHP等就没啥区别了。如果再冠上更了不起的Node.js，就有点名不符实了。所以这里我稍加整理，看看和大家想的是否一样<\/p>\n<h3>技术栈演进<\/h3>\n<p>自从ES 2015（俗称ES 6）在Node.js 落地之后，整个Node.js开发都发生了翻天覆地的变化。自从0.10开始，Node.js就逐渐的加入了ES 6特性，比如0.12就可以使用generator，才导致寻求异步流程控制的tj写出了co这个著名的模块，继而诞生了Koa框架。但是在4.0之前，一直都是要通过flag才能开启generator支持，故而Koa 1.0迟迟未发布，在Node 4.0发布才发布的Koa 1.0。<\/p>\n<blockquote>\n<p>2015年，成熟的传统，而2016年，变革开始<\/p>\n<\/blockquote>\n<p>核心变更：es语法支持<\/p>\n<ul>\n<li>使用Node.js 4.x或5.x里的es6特性，如果想玩更高级的，可以使用<a href>babel<\/a>编译支持es7特性，或者typescript<\/li>\n<li>合理使用<a href=\"https://github.com/feross/standard\">standard<\/a>  或者 xo 代码风格约定<\/li>\n<li>适当的引入ES 6语法，只要Node.js SDK支持的，都可以使用<\/li>\n<li>需要大家重视OO（面向对象）写法的学习和使用，虽然ES 6的OO机制不健全，但这是大方向，以后会一直增强。OO对于大型软件开发更好。这其实也是我看好typescript的原因。<\/li>\n<\/ul>\n<p>对比一下变革前后的技术栈选型，希望读者能够从中感受到其中的变化<\/p>\n<table>\n<thead>\n<tr>\n<th>分类<\/th>\n<th>2015年<\/th>\n<th>2016年<\/th>\n<th>选型原因<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>Web框架<\/td>\n<td>express 4.x<\/td>\n<td>koa 1.0 &amp;&amp; 2.0 （koa2.0刚发布不久，喜欢折腾的可以考虑）<\/td>\n<td>主要在流程控制上的便利，异步毕竟要时刻注意，心累<\/td>\n<\/tr>\n<tr>\n<td>数据库<\/td>\n<td>mongoose（mongodb）<\/td>\n<td>mongoose（mongodb）<\/td>\n<td>对mongodb和mysql支持都一样，不过是mongodb更简单，足以应付绝大部分场景<\/td>\n<\/tr>\n<tr>\n<td>异步流程控制<\/td>\n<td>bluebird（Promise/A+实现）<\/td>\n<td>bluebird（Promise/A+实现）1） Koa 1.0 使用co + generator 2） Koa 2.0 使用async函数<\/td>\n<td>流程控制演进路线，从promise到async函数，无论如何，promise都是基石，必要掌握的<\/td>\n<\/tr>\n<tr>\n<td>模板引擎（视图层）<\/td>\n<td>ejs &amp;&amp; jade<\/td>\n<td>jade &amp;&amp; nunjucks<\/td>\n<td>给出了2种，一种可读性好，另一种简洁高效，都是非常好的<\/td>\n<\/tr>\n<tr>\n<td>测试<\/td>\n<td>mocha<\/td>\n<td>ava<\/td>\n<td>mocha是Node.js里著名的测试框架，但对新特性的支持没有ava那么好，而ava基于babel安装也要大上好多<\/td>\n<\/tr>\n<tr>\n<td>调试<\/td>\n<td>node-inspector<\/td>\n<td>VSCode<\/td>\n<td>在Node 6和7出来之后，node-inspector支持的不是那么好，相反VSCode可视化，简单，文件多时也不卡，特别好用<\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<h3>预处理器<\/h3>\n<p>前端预处理可分3种<\/p>\n<ul>\n<li>模板引擎<\/li>\n<li>css预处理器<\/li>\n<li>js友好语言<\/li>\n<\/ul>\n<p>这些都离不开Node.js的支持，对于前端工程师来说，使用Node.js来实现这些是最方便不过的。<\/p>\n<table>\n<thead>\n<tr>\n<th>名称<\/th>\n<th>实现<\/th>\n<th>描述<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>模板引擎<\/td>\n<td>art\\mustache\\ejs\\hbs\\jade \u2026<\/td>\n<td>上百种之多，自定义默认，编译成html，继而完成更多操作<\/td>\n<\/tr>\n<tr>\n<td>css预处理器<\/td>\n<td>less\\sass\\scss\\rework\\postcss<\/td>\n<td>自定义语法规则，编译成css<\/td>\n<\/tr>\n<tr>\n<td>js友好语言<\/td>\n<td>coffeescript、typescript<\/td>\n<td>自定义语法规则、编译成js<\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<h3>跨平台<\/h3>\n<p>跨平台指的是PC端、移动端、Web/H5<\/p>\n<table>\n<thead>\n<tr>\n<th>平台<\/th>\n<th>实现<\/th>\n<th>点评<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>Web/H5<\/td>\n<td>纯前端<\/td>\n<td>不必解释<\/td>\n<\/tr>\n<tr>\n<td>PC客户端<\/td>\n<td>nw.js和electron<\/td>\n<td>尤其是atom和vscode编辑器最为著名，像钉钉PC端，微信客户端、微信小程序IDE等都是这样的，通过web技术来打包成PC客户端<\/td>\n<\/tr>\n<tr>\n<td>移动端<\/td>\n<td>cordova（旧称PhoneGap），基于cordova的ionicframework<\/td>\n<td>这种采用h5开发，打包成ipa或apk的应用，称为Hybrid开发（混搭），通过webview实现所谓的跨平台，应用的还是非常广泛的<\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<h3>构建工具<\/h3>\n<p>说起构建工具，大概会想到make、ant、rake、gradle等，其实Node.js里有更多实现<\/p>\n<table>\n<thead>\n<tr>\n<th>名称<\/th>\n<th>介绍<\/th>\n<th>点评<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>jake<\/td>\n<td>基于coffeescript的大概都熟悉这个，和make、rake类似<\/td>\n<td>经典传统<\/td>\n<\/tr>\n<tr>\n<td>grunt<\/td>\n<td>dsl风格的早期著名框架<\/td>\n<td>配置非常麻烦<\/td>\n<\/tr>\n<tr>\n<td>gulp<\/td>\n<td>流式构建，不会产生中间文件，利用Stream机制，处理大文件和内存有优势，配置简单，只有懂点js就能搞定<\/td>\n<td>grunt的替代品<\/td>\n<\/tr>\n<tr>\n<td>webpack + npm scripts<\/td>\n<td>说是构建工具有点过，但二者组合勉强算吧，loader和plugin机制还是非常强大的<\/td>\n<td>流行而已<\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<p>构建工具都不会特别复杂，所以Node.js世界里有非常多的实现，还有人写过node版本的make呢，玩的很嗨<\/p>\n<h3>HTTP Proxy<\/h3>\n<ul>\n<li>请求代理<\/li>\n<li>SSR &amp;&amp; PWA<\/li>\n<li>Api Proxy<\/li>\n<\/ul>\n<p>1）请求代理<\/p>\n<p>对于http请求复杂定制的时候，你是需要让Node.js来帮你的，比如为了兼容一个历史遗留需求，在访问某个CSS的时候必须提供HEADER才可以，如果放到静态server或cdn上是做不到的。<\/p>\n<p>2）SSR &amp;&amp; PWA<\/p>\n<p>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境<\/p>\n<p>3）Api Proxy<\/p>\n<p>产品需要应变，后端不好变，一变就要设计到数据库、存储等，可能引发事故。而在前端相对更容易，前端只负责组装服务，而非真正对数据库进行变动，所以只要服务api粒度合适，在前端来处理是更好的。<\/p>\n<p>Api的问题<\/p>\n<ul>\n<li>一个页面的Api非常多<\/li>\n<li>跨域，Api转发<\/li>\n<li>Api返回的数据对前端不友好，后端讨厌（应付）前端，几种api都懒得根据ui/ue去定制，能偷懒就偷懒<\/li>\n<li>需求决定Api，Api不一定给的及时<\/li>\n<\/ul>\n<p>所以，在前端渲染之余，加一层Api Proxy是非常必要的。淘宝早起曾公开过一张架构图，在今天看来，依然不过时<\/p>\n<p><img src=\"//dn-cnode.qbox.me/Fr8cGvus0i58atULAnoe-Cv4nu5m\" alt=\"taobao.jpg\"><\/p>\n<ul>\n<li>左侧半边，浏览器和Node.js Server通信可以有多种协议，HTML、RESTfull、BigPipe、Comet、Socket等，已经足够我们完成任何想做的事儿了<\/li>\n<li>右侧半边，是Node.js实现的WebServer，Node服务分了2个部分\n<ul>\n<li>常规的Http服务，即大块部分二<\/li>\n<li>ModelProxy指的是根据Server端的服务，组成并转化成自身的Model层。磨蹭用于为Http服务提供更好的接口<\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<p>这里的Model Proxy其实就是我们所说的Api Proxy，这张图里只是说了结果，把聚合的服务转成模型，继而为HTTP服务提供Api。<\/p>\n<p>下面我们再深化一下Api Proxy的概念<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FpAZo4aPQysJyciBvzUCU9uxb-vf\" alt=\"proxy.png\"><\/p>\n<p>这里的Node Proxy做了2件事儿，Api和渲染辅助。<\/p>\n<ul>\n<li>前端的异步ajax请求，可以直接访问Api<\/li>\n<li>如果是直接渲染或者bigpipe等协议的，需要在服务器端组装api，然后再返回给浏览器。<\/li>\n<\/ul>\n<p>所以Api后面还有一个服务组装，在微服务架构流行的今天，这种服务组装放到Node Proxy里的好处尤其明显。既可以提高前端开发效率，又可以让后端更加专注于服务开发。甚至如果前端团队足够大，可以在前端建一个Api小组，专门做服务集成的事儿。<\/p>\n<h3>Api服务<\/h3>\n<p>说完了Proxy，我们再看看利益问题。Node.js向后端延伸，必然会触动后端开发的利益。那么Proxy层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。<\/p>\n<p>但是Node.js能不能做这部分呢？答案是能的 ，这个是和Java、PHP类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以Java、PHP等为主，所以要想吃到这部分并不容易。<\/p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于Node.js，简单，快速，高效<\/li>\n<li>微服务架构下的某些服务，使用Node.js开发，是比较合理的<\/li>\n<\/ul>\n<p>国内这部分一直没有做的很好，所以Node.js在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对Node.js的误解<\/p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢<\/li>\n<li>运维，其实很简单，比其他语言之简单，日志采集、监控也非常简单<\/li>\n<li>模块稳定性，对于Mongodb、MySQL、Redis等还是相当不错，但其他的数据库支持可能没那么好。<\/li>\n<li>安全问题，<\/li>\n<\/ul>\n<p>这些对于提供Api服务来说已经足够了。<\/p>\n<h3>其他<\/h3>\n<table>\n<thead>\n<tr>\n<th>用途<\/th>\n<th>说明<\/th>\n<th>前景<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>爬虫<\/td>\n<td>抢了不少Python的份额，整体来说简单，实用<\/td>\n<td>看涨<\/td>\n<\/tr>\n<tr>\n<td>命令行工具<\/td>\n<td>写工具、提高效率，node+npm真是无出其右<\/td>\n<td>看涨<\/td>\n<\/tr>\n<tr>\n<td>微服务与RPC<\/td>\n<td>Node做纯后端不好做，但在新项目和微服务架构下，必有一席之地<\/td>\n<td>看涨<\/td>\n<\/tr>\n<tr>\n<td>微信公众号开发<\/td>\n<td>已经火了2年多了，尤其是付费阅读领域，还会继续火下去，gitchat就是实用Node.js做的，而且还在招人<\/td>\n<td>看涨<\/td>\n<\/tr>\n<tr>\n<td>反向代理<\/td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的<\/td>\n<td>看涨<\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<h2>更好的写法<\/h2>\n<h3>Async函数与Promise<\/h3>\n<ul>\n<li>Async函数是趋势，Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7<\/a>)了，Node.js 7.0+支持还会远么？<\/li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。<\/li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。<\/li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？<\/li>\n<\/ul>\n<p>我整理了一张图，更直观一些。<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FkcPwxdGHSCHFvA2nU0ub0zYNRt4\" alt=\"async-all.png\"><\/p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用<\/li>\n<li>蓝色是Generator，过度货<\/li>\n<li>绿色是Async函数，趋势<\/li>\n<\/ul>\n<p><strong>结论<\/strong>：Promise是必须会的，那你为什么不顺势而为呢？<\/p>\n<p><strong>推荐<\/strong>：使用Async函数 + Promise组合，如下图所示。<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FhVQF1FKB6sNkoFTc3gU-SVnkGtm\" alt=\"async-suggest.png\"><\/p>\n<p><strong>实践<\/strong><\/p>\n<p>合理的结合Promise和Async函数是可以非常高效的，但也要因场景而异<\/p>\n<ul>\n<li>Promise更容易做promisefyAll（比如使用bluebird）<\/li>\n<li>Async函数无法批量操作<\/li>\n<\/ul>\n<p>那么，在常见的Web应用里，我们总结的实践是，dao层使用Promise比较好，而service层，使用Async/Await更好。<\/p>\n<p>dao层使用Promise：<\/p>\n<ul>\n<li>crud<\/li>\n<li>单一模型的方法多<\/li>\n<li>库自身支持Promise<\/li>\n<\/ul>\n<p>这种用promisefyAll基本几行代码就够了，一般单一模型的操作，不会特别复杂，应变的需求基本不大。<\/p>\n<p>而service层一般是多个Model组合操作，多模型操作就可以拆分成多个小的操作，然后使用Await来组合，看起来会更加清晰，另外对需求应变也是非常容易的。<\/p>\n<h3>ES.next<\/h3>\n<blockquote>\n<p>Node.js + ES.next = ♥<\/p>\n<\/blockquote>\n<h3>Flow &amp;&amp; TypeScript<\/h3>\n<blockquote>\n<p>Type Systems Will Make You a Better JavaScript Developer<\/p>\n<\/blockquote>\n<h3>ES6模块<\/h3>\n<p>现在ES6自带了模块标准， 也是JS第一次支持module（之前的CommonJS、AMD、CMD都不算）， 但目前的所有Node.js版本都没有支持，目前只能用用Traceur、BabelJS， 或者TypeScript把ES6代码转化为兼容ES5版本的js代码，ES6模块新特性非常吸引人，下面简要说明。<\/p>\n<p>ES6 模块的目标是创建一个同时兼容CommonJS和AMD的格式，语法更加紧凑，通过编译时加载，使得编译时就能确定模块的依赖关系，效率要比 CommonJS 模块的加载方式高。而对于异步加载和配置模块加载方面，则借鉴AMD规范，其效率、灵活程度都远远好于CommonJS写法。<\/p>\n<ul>\n<li>语法更紧凑<\/li>\n<li>结构更适于静态编译（比如静态类型检查，优化等）<\/li>\n<li>对于循环引用支持更好<\/li>\n<\/ul>\n<p>ES6 模块标准只有2部分，它的用法更简单，你根本不需要关注实现细节:<\/p>\n<ul>\n<li>声明式语法：模块导入import、导出export，没有require了<\/li>\n<li>程式化加载API：可以配置模块是如何加载，以及按需加载。<\/li>\n<\/ul>\n<h3>多模块管理器：Lerna<\/h3>\n<blockquote>\n<p>A tool for managing JavaScript projects with multiple packages.<\/p>\n<\/blockquote>\n<p><a href=\"https://lernajs.io/\">https://lernajs.io/<\/a><\/p>\n<p>在设计框架的时候，经常做的事儿是进行模块拆分，继而提供插件或集成机制，这样是非常好的做法。但问题也随之而来，当你的模块模块非常多时，你该如何管理你的模块呢？<\/p>\n<ul>\n<li>法1：每个模块都建立独立的仓库<\/li>\n<li>法2：所有模块都放到1个仓库里<\/li>\n<\/ul>\n<p>法1虽然看起来干净，但模块多时，依赖安装，不同版本兼容等，会导致模块间依赖混乱，出现非常多的重复依赖，极其容易造成版本问题。这时法2就显得更加有效，对于测试，代码管理，发布等，都可以做到更好的支持。<\/p>\n<p>Lerna就是基于这种初衷而产生的专门用于管理Node.js多模块的工具，当然，前提是你有很多模块需要管理。<\/p>\n<p>你可以通过npm全局模块来安装Lerna，官方推荐直接使用Lerna 2.x版本<\/p>\n<h3>更好的NPM替代品：Yarn<\/h3>\n<p>Yarn是开源JavaScript包管理器，由于npm在扩展内部使用时遇到了大小、性能和安全等问题，Facebook携手来自Exponent、Google和Tilde的工程师，在大型JavaScript框架上打造和测试了Yarn，以便其尽可能适用于多人开发。Yarn承诺比各大流行npm包的安装更可靠，且速度更快。根据你所选的工作包的不同，Yarn可以将安装时间从数分钟减少至几秒钟。Yarn还兼容npm注册表，但包安装方法有所区别。其使用了lockfiles和一个决定性安装算法，能够为参与一个项目的所有用户维持相同的节点模块（node_modules）目录结构，有助于减少难以追踪的bug和在多台机器上复制。<\/p>\n<p>Yarn还致力于让安装更快速可靠，支持缓存下载的每一个包和并行操作，允许在没有互联网连接的情况下安装（如果此前有安装过的话）。此外，Yarn承诺同时兼容npm和Bower工作流，让你限制安装模块的授权许可。<\/p>\n<p>2016年10月份, Yarn在横空出世不到一周的时间里，github上的star数已经过万，可以看出大厂及社区的活跃度，以及解决问题的诚意，大概无出其右了！<\/p>\n<p>替换的原因<\/p>\n<ul>\n<li>在Facebook的大规模 npm 都工作的不太好<\/li>\n<li>npm拖慢了公司的ci工作流<\/li>\n<li>对一个检查所有的模块也是相当低效的<\/li>\n<li>npm被设计为是不确定性的，而Facebook工程师需要为他们的DevOps工作流提供一直和可依赖的系统<\/li>\n<\/ul>\n<p>与hack npm限制的做法相反，Facebook编写了Yarn<\/p>\n<ul>\n<li>Yarn 的本地缓存文件做的更好<\/li>\n<li>Yarn 可以并行它的一些操作，这加速了对新模块的安装处理<\/li>\n<li>Yarn 使用lockfiles，并用确定的算法来创建一个所有跨机器上都一样的文件<\/li>\n<li>出于安全考虑，在安装进程里，Yarn 不允许编写包的开发者去执行其他代码<\/li>\n<\/ul>\n<blockquote>\n<p>Yarn, which promises to even give developers that don\u2019t work at Facebook\u2019s scale a major performance boost, still uses the npm registry and is essentially a drop-in replacement for the npm client.<\/p>\n<\/blockquote>\n<p>很多人说和ruby的gem机制类似，都生成lockfile。确实是一个很不错的改进，在速度上有很大改进，配置cnpm等国内源来用，还是相当爽的。<\/p>\n<h3>友好语言<\/h3>\n<ul>\n<li>过气的Coffeescript，不多说<\/li>\n<li><a href=\"https://babeljs.io/\">Babel<\/a> - also an ES6 to ES5 transpiler that\u2019s growing in popularity possibly because it also supports React\u2019s JSX syntax. As of today it supports the most ES6 features at a somewhat respectable 73%.<\/li>\n<li><a href=\"http://www.typescriptlang.org/\">TypeScript<\/a> - a typed superset of JavaScript that not only compiles ES6 to ES5 (or even ES3) but also supports optional variable typing. TypeScript only supports 53% of ES6 features.<\/li>\n<\/ul>\n<h2>总结<\/h2>\n<blockquote>\n<p>坦诚的力量是无穷的<\/p>\n<\/blockquote>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。<\/p>\n<p>直面问题才能有更好的解决方式，Node.js你值得拥有！<\/p>\n<\/div>","title":"2017，我们来聊聊 Node.js","last_reply_at":"2017-05-13T09:10:40.433Z","good":true,"top":true,"reply_count":55,"visit_count":13947,"create_at":"2017-04-13T02:41:41.818Z","author":{"loginname":"i5ting","avatar_url":"https://avatars0.githubusercontent.com/u/3118295?v=3&s=120"}},{"id":"591818a4ba8670562a40f0dd","author_id":"591744d59e32cc84569a6f49","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>注重细节的 前端才是好运维<\/p>\n<\/blockquote>\n<h3>vue-music<\/h3>\n<p>希望它会成为用vue实现网易云音乐最全的webapp，我们的目标是更像，更快，更优雅<\/p>\n<h4>网易云音乐（移动版）<\/h4>\n<ul>\n<li><a href=\"https://github.com/Binaryify/NeteaseCloudMusicApi\">api来源<\/a>(感谢Binaryify不断更新的网易云音乐接口，这也将是这个项目不断拓展下去的坚实依托)<\/li>\n<li><a href=\"https://github.com/ddqre12345/vue-music\">源码地址<\/a><\/li>\n<li><a href=\"http://118.89.226.181:8080\">项目预览<\/a>（web端在chrome调试模式下效果更佳）<\/li>\n<li>针对segmenfault类app暂时无法有效预览的问题，建议粘贴http://118.89.226.181:8080到手机其他浏览器体验<\/li>\n<li>项目所提供请求地址希望仅供预览使用，如果在开发过程中调用，可能会引起服务崩溃，本地开发建议参考<a href=\"https://github.com/Binaryify/NeteaseCloudMusicApi\">api来源<\/a>，配置本地服务器代理，健康绿色环保<\/li>\n<\/ul>\n<h4>使用技术<\/h4>\n<ul>\n<li>Vue2：采用最新Vue2的语法<\/li>\n<li>Vuex：主要实现非父子组件通讯<\/li>\n<li>vue-router：管理单页面应用路由<\/li>\n<li>axios：发起http请求<\/li>\n<li>stylus：css预处理语言<\/li>\n<li>Express：vue-cli使用Express做服务器。<\/li>\n<li>Webpack：自动化构建工具，主要配置由vue-cli脚手架提供。<\/li>\n<li>ES6：采用ES6语法。<\/li>\n<li>CSS3：CSS3动画及样式。<\/li>\n<\/ul>\n<h4>项目进度<\/h4>\n<blockquote>\n<p>已完成<\/p>\n<\/blockquote>\n<ul>\n<li>网易云（轮播，推荐歌单，独家放送，推荐MV，网友精选歌单（最新，最热），排行榜）<\/li>\n<li>搜索（热门搜索，搜索结果包括单曲，歌手，专辑，歌单，用户及其滑动切换）<\/li>\n<li>播放页面（歌词，碟片切换）<\/li>\n<li>歌手，专辑，歌单，用户等详情展示<\/li>\n<li>音乐播放功能（切歌，播放列表，播放进度显示）<\/li>\n<\/ul>\n<blockquote>\n<p>效果图<\/p>\n<\/blockquote>\n<p><img src=\"https://github.com/ddqre12345/vue-music/blob/master/static/vue-music-1.gif?raw=true\" alt=\"发现\">\n<img src=\"https://github.com/ddqre12345/vue-music/blob/master/static/vue-music-2.gif?raw=true\" alt=\"搜索\">\n<img src=\"https://github.com/ddqre12345/vue-music/blob/master/static/vue-music-3.gif?raw=true\" alt=\"详情\">\n<img src=\"https://github.com/ddqre12345/vue-music/blob/master/static/vue-music-4.gif?raw=true\" alt=\"测试\">\n<img src=\"https://github.com/ddqre12345/vue-music/blob/master/static/vue-music-5.gif?raw=true\" alt=\"歌词\"><\/p>\n<p>图片就到这里，<a href=\"http://118.89.226.181:8080\">more &gt;<\/a><\/p>\n<blockquote>\n<p>下阶段计划<\/p>\n<\/blockquote>\n<ul>\n<li>MV播放，希望这个功能能走下去<\/li>\n<li>\u201c我的\u201d争取还是做出来吧，尽管可能没人敢用<\/li>\n<li>完善各个页面的功能吧，持续优化<\/li>\n<\/ul>\n<h4>安装运行（安装运行前请确定已安装node环境）<\/h4>\n<ul>\n<li>git clone：<a href=\"https://github.com/ddqre12345/vue-music.git\">https://github.com/ddqre12345/vue-music.git<\/a><\/li>\n<li>环境安装：npm install<\/li>\n<li>启动服务：npm run dev<\/li>\n<li>发布代码：npm run build<\/li>\n<li>代码检查：npm run lint<\/li>\n<\/ul>\n<h4>项目构成<\/h4>\n<p>&lt;pre&gt;\n├── build              // 构建服务和webpack配置\n├── config             // 项目不同环境的配置\n├── dist               // 项目build目录\n├── index.html         // 项目入口文件\n├── package.json       // 项目配置文件\n├── static       \t // 放置静态资源\n├── src                // 生产目录\n│   ├── api        //  api请求\n│   ├── assets         // 图片资源\n│   ├── common          // 公共的css js images资源\n│   ├── components     // 各种组件\n│   ├── views          // 各个视图\n│   ├── vuex           // vuex状态管理器\n│   ├── App.vue         // 主页面\n│   ├── router.js     // 路由配置器\n│   └── main.js        // Webpack 预编译入口\n&lt;/pre&gt;<\/p>\n<h4>最后<\/h4>\n<p>到这里，欢迎大家提issue，pr，star，如果喜欢可以watch，每周应该都会有些小更新，本项目仅供学习交流使用，切勿用于商业用途<\/p>\n<\/div>","title":"vue 全家桶系列之网易云音乐（移动版）","last_reply_at":"2017-05-14T08:43:16.905Z","good":false,"top":false,"reply_count":0,"visit_count":4,"create_at":"2017-05-14T08:43:16.905Z","author":{"loginname":"ddqre12345","avatar_url":"https://avatars0.githubusercontent.com/u/16521402?v=3&s=120"}},{"id":"5918180dd371b6372a8af99e","author_id":"590a76b8782dbc4b183ed02b","tab":"share","content":"<div class=\"markdown-text\"><p>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\u201cutf-8\u201d&gt;\n&lt;title&gt;html5桌面通知&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;input type=\u201cbutton\u201d value=\u201c开启桌面通知\u201d onclick=\u201cshowNotice(\u2019\u2019,\u2018HTML5桌面消息\u2019);\u201d&gt;\n&lt;script&gt;\nfunction showDeskTopNotice(title,msg){\nvar Notification = window.Notification || window.mozNotification || window.webkitNotification;\nif(Notification){\nNotification.requestPermission(function(status){\n//status默认值\u2019default\u2019等同于拒绝 \u2018denied\u2019 意味着用户不想要通知 \u2018granted\u2019 意味着用户同意启用通知\nif(\u201cgranted\u201d != status){\nreturn;\n}else{\nvar tag = \u201csds\u201d+Math.random();\nvar notify = new Notification(\ntitle,\n{\ndir:\u2018auto\u2019,\nlang:\u2018zh-CN\u2019,\ntag:tag,//实例化的notification的id\nicon:\u2018<a href=\"http://www.yinshuajun.com/static/img/favicon.ico\">http://www.yinshuajun.com/static/img/favicon.ico<\/a>\u2019,//通知的缩略图,//icon 支持ico、png、jpg、jpeg格式\nbody:msg //通知的具体内容\n}\n);\nnotify.onclick=function(){\n//如果通知消息被点击,通知窗口将被激活\nwindow.focus();\n},\nnotify.onerror = function () {\nconsole.log(\u201cHTML5桌面消息出错！！！\u201d);\n};\nnotify.onshow = function () {\nsetTimeout(function(){\nnotify.close();\n},2000)\n};\nnotify.onclose = function () {\nconsole.log(\u201cHTML5桌面消息关闭！！！\u201d);\n};\n}\n});\n}else{\nconsole.log(\u201c您的浏览器不支持桌面消息\u201d);\n}\n};\nshowDeskTopNotice(&quot;&quot;,\u201cHTML5桌面消息\u201d)\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;<\/p>\n<\/div>","title":"H5桌面消息通知Notification","last_reply_at":"2017-05-14T08:40:45.627Z","good":false,"top":false,"reply_count":0,"visit_count":7,"create_at":"2017-05-14T08:40:45.627Z","author":{"loginname":"nasaplayer","avatar_url":"https://avatars0.githubusercontent.com/u/26316854?v=3&s=120"}},{"id":"5915d78c3504ce1c2ac45bcb","author_id":"58d4e6156f8b9bf02d1d0a92","tab":"share","content":"<div class=\"markdown-text\"><p>第二章里面讲模块分析，讲到C/C++模块编译的时候直接就晕了😖，一大片C/C++代码<\/p>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD<\/a><\/p>\n<\/div>","title":"朴灵大大的书好难看懂","last_reply_at":"2017-05-14T08:30:39.098Z","good":false,"top":false,"reply_count":11,"visit_count":399,"create_at":"2017-05-12T15:41:00.030Z","author":{"loginname":"q86002618","avatar_url":"https://avatars0.githubusercontent.com/u/23697209?v=3&s=120"}},{"id":"5917ebb5d371b6372a8af998","author_id":"591086413504ce1c2ac459b6","tab":"ask","content":"<div class=\"markdown-text\"><p>rt<\/p>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD<\/a><\/p>\n<\/div>","title":"新人，想问一下现在es6是不是有兼容问题？新人学es6有必要吗？","last_reply_at":"2017-05-14T08:27:57.696Z","good":false,"top":false,"reply_count":3,"visit_count":51,"create_at":"2017-05-14T05:31:33.058Z","author":{"loginname":"chocolateback","avatar_url":"https://avatars3.githubusercontent.com/u/18118351?v=3&s=120"}},{"id":"5916ff38ba8670562a40f0ab","author_id":"573212537abbbd520cb244b3","tab":"ask","content":"<div class=\"markdown-text\"><p>在Atom里面输入log会自动补全成console.log()。\n不知道在vscode怎么实现这个功能呢？<\/p>\n<\/div>","title":"最近换了vscode有一些疑问，望指教！","last_reply_at":"2017-05-14T08:26:02.347Z","good":false,"top":false,"reply_count":3,"visit_count":165,"create_at":"2017-05-13T12:42:32.819Z","author":{"loginname":"dlyt","avatar_url":"https://avatars3.githubusercontent.com/u/18431616?v=3&s=120"}},{"id":"5916137cd371b6372a8af941","author_id":"539822caa087f4562019af24","tab":"job","content":"<div class=\"markdown-text\"><p>本人常用的语言 php nodejs python\n数据库 mysql mongodb\n系统 ubuntu\n容器 docker<\/p>\n<p>本人酷爱编程，从初中开始自学编程以来做过很多项目，也在国外工作过，由于家庭原因暂时没办法去外地工作，先寻找一份合适的工作。<\/p>\n<p>本人接受视频工作、会议，如果工作中需要用到新的技术，我可以在一个星期内完成。<\/p>\n<p>薪资不要太低都能接受！！！<\/p>\n<p>有需要的可以联系我。微信：ireoos  qq：19980108<\/p>\n<p>From <a href=\"https://github.com/soliury/noder-react-native\">Noder<\/a><\/p>\n<\/div>","title":"本人寻找一份适合在家的工作，只为混口饭吃","last_reply_at":"2017-05-14T08:18:18.364Z","good":false,"top":false,"reply_count":5,"visit_count":94,"create_at":"2017-05-12T19:56:44.775Z","author":{"loginname":"Ireoo","avatar_url":"https://avatars0.githubusercontent.com/u/5162679?v=3&s=120"}},{"id":"590a84f4bbaf2f3f569be505","author_id":"53a8cadda087f4562002c4cf","tab":"job","content":"<div class=\"markdown-text\"><p>打算玩玩微服务、Mesh 网络？\n想要亲密接触一下机器学习？\n向往让数千万人每天使用你写的代码？\n好奇未来独角兽公司个位数员工的滋味？<\/p>\n<p>来我们脸云(上海)互联网科技有限公司，这些机会都有。公司刚刚设立，巨额投资已经搞定，研发和产品负责人都有十多年一线经验，诚邀有战斗力的小伙伴共创未来。有意请发简历到 <a href=\"mailto:hire@facialcloud.com\">hire@facialcloud.com<\/a> 。<\/p>\n<h2>首先，我希望你认同以下理念：<\/h2>\n<ol>\n<li>程序员的工作是编写价值、提交正确性，而价值源于用户需求，正确性要用测试证明。<\/li>\n<li>程序员用代码说话 (Talk is cheap, show me the code)。<\/li>\n<li>创业团队成员应该自我驱动、有责任感、思想开放。<\/li>\n<\/ol>\n<h3>[Node.js 工程师]<\/h3>\n<p>职责：\n在资深 Node.js 工程师的带领下开发、维护系统各项服务。<\/p>\n<p>要求：<\/p>\n<ol>\n<li>扎实的 Node.js 及 JavaScript(ES6) 基础<\/li>\n<li>良好的工程习惯<\/li>\n<li>一年以上服务端实际开发经验<\/li>\n<li>计算机相关专业本科以上学历，或同等基础<\/li>\n<li>全栈待遇从优<\/li>\n<\/ol>\n<p>薪资福利：\n10~20K/月，该有的福利都会有<\/p>\n<h3>[微信/前端工程师]<\/h3>\n<p>职责：\n配合产品及设计实现微信、Web 等平台上的用户功能。<\/p>\n<p>要求：<\/p>\n<ol>\n<li>扎实的 HTML/CSS/JavaScript 基础<\/li>\n<li>一年以上实际经验，或有独立完成的作品<\/li>\n<li>具有良好的工程习惯<\/li>\n<li>熟悉 Vue 或  React 之一，有微信 SDK 或小程经验优先<\/li>\n<li>计算机相关专业本科以上学历，或同等基础，能力突出可放宽<\/li>\n<li>全栈待遇从优<\/li>\n<\/ol>\n<p>薪资福利：\n10~20K/月，该有的福利都会有<\/p>\n<h3>[运维工程师]<\/h3>\n<p>职责：\n与开发人员一起完成服务布署、监控与优化<\/p>\n<p>要求：\n1.熟练掌握 Linux 系统管理\n2.熟练使用任意一种系统监控平台\n3.熟悉文件、数据库备份、恢复\n4.有3年以上云服务器管理经验\n5.能独立完成简单的系统和网络分析<\/p>\n<ol>\n<li>有 Docker 服务管理经验从优<\/li>\n<li>DevOps 待遇从优<\/li>\n<\/ol>\n<p>薪资福利：\n10~20K/月，该有的福利都会有<\/p>\n<hr>\n<p>有意请发简历到 <a href=\"mailto:hire@facialcloud.com\">hire@facialcloud.com<\/a><\/p>\n<\/div>","title":"[上海] 脸云(上海)招聘 Node.js 微服务开发、微信前端开发及运维","last_reply_at":"2017-05-14T07:39:33.778Z","good":false,"top":false,"reply_count":7,"visit_count":378,"create_at":"2017-05-04T01:33:40.504Z","author":{"loginname":"pinxue","avatar_url":"https://avatars3.githubusercontent.com/u/958237?v=3&s=120"}},{"id":"58facf679116585a56e20871","author_id":"584139e9539c22b15689981c","tab":"ask","content":"<div class=\"markdown-text\"><p>我们是一个小团队，全栈JS，后端用的Nodejs，做的是在线epub电子书阅读器，网址：<a href=\"http://www.neat-reader.cn\">www.neat-reader.cn<\/a>\n因为我们有很多用户想打开 mobi 格式的电子书，或是希望提供一个 mobi 转码成 epub 的功能。所以我们想要搭建一个专门的转码服务器。<\/p>\n<p>至于转码的方式，我们是用一个叫 Calibre 的开源项目提供的 CMD 命令行。\n目前我们在阿里云上有一个实验服务器（1核2G内存，Windows Server），用于测试转码服务器的效果。\n现在遇到了很奇怪的问题：在本地跑的好好的，但是一旦上到服务器，就会出错，导致服务器崩溃。实在找不到原因，只能求助于大家了。<\/p>\n<p>用户使用我们的服务，以及我们的程序运行的流程如下：\n1.用户打开转码页面，选择一个文件，以及目标转码格式，然后点提交。\n2.此时前端会向服务器发送一个任务提交请求，后端会在文本数据库中（用的nedb）创建一个task，有id信息，还有新上传的文件要存在哪里之类的信息，最重要的是一个工作状态值：uploading。然后把这些数据返回给前端\n3.前端收到task创建成功的返回后，开始上传文件到指定地点（上传使用的是一个叫formidable的包），上传成功后，这个task的状态值会改为waiting。同时告诉前端，文件传完了，然后前端会每一秒使用task id询问服务器：我的这个task现在怎么样了\n4.后端每次收到前端的询问请求，都会做一次判断，看看这个task是不是整个task表中，第一个状态为waiting的，如果是，则调用CMD对文件进行转码（CMD使用的是node-cmd包，这个包运行完成后会输出两种状态，要么成功，要么失败，其他我们一概不知），同时把这个task的状态改为processing，期间前端询问时，我们就告诉它正在processing，过1秒你再来问！等CMD成功或是失败后，task的状态就会修改成success或是fail。此时当前端询问时，就告诉它，如果成功，告知下载地址，如果失败，告知失败原因。到此为止，一个转码请求就算结束了。\n我们认为按照这样的设计，可以保证很多用户同时提交任务也不会导致崩溃。<\/p>\n<p>类似的流程可以看这个网站：<a href=\"http://www.epubconverter.com/epub-to-mobi-converter/\">http://www.epubconverter.com/epub-to-mobi-converter/<\/a><\/p>\n<p>我们现在遇到的问题是：本地运行好好的，同时打开3个浏览器提交转码任务都没问题。但是一旦上到服务器，随便传两下就崩溃了。\n我们猜测原因可能是下列，但是又不知道怎么确定：\n1.因为服务器是1核的，本地机器是多核的，所以出问题\n2.因为本地的IO操作速度非常快，但是在服务器上，因为有了上传和下载流程，导致程序出问题\n3.node-cmd出问题，可能每次启动cmd命令都会影响程序<\/p>\n<p>希望各位大神帮帮忙，看看我们的设计有什么问题，可能的原因是什么，怎么解决。\n不胜感激啊！<\/p>\n<p>PS:补充一下在线上的错误信息。每次运行时，第一次转码都能成功，第二次再转，就会出现如下的报错\n<img src=\"//dn-cnode.qbox.me/FhLCgbgG7wWbLeLRwJrcnR61FunH\" alt=\"TIM截图20170422141341.png\"><\/p>\n<\/div>","title":"在阿里云上使用Node搭建\u201c图书转码\u201c服务遇到了天坑，实在搞不定了，跪求帮助（如果有高人愿意出手帮忙，我们可以掏钱咨询）","last_reply_at":"2017-05-14T07:25:50.702Z","good":false,"top":false,"reply_count":24,"visit_count":884,"create_at":"2017-04-22T03:35:03.360Z","author":{"loginname":"hz0324","avatar_url":"https://avatars3.githubusercontent.com/u/5040078?v=3&s=120"}},{"id":"584a18289ff0dbf333450901","author_id":"57a35afa5c5423c3352d7bdf","tab":"share","content":"<div class=\"markdown-text\"><p>这篇文章讲解一下<a href=\"https://github.com/callmelanmao/yunshare\">yunshare<\/a>项目的爬虫模型。<\/p>\n<p>使用nodejs开发爬虫很简单，不需要类似python的scrapy这样的爬虫框架，只需要用request或者superagent这样的http库就能完成大部分的爬虫工作了。<\/p>\n<p>使用nodejs开发爬虫半年左右了，爬虫可以很简单，也可以很复杂。简单的爬虫定向爬取一个网站，可能有个几万或者几十万的页面请求，复杂的爬虫类似google bot这样搜索引擎的蜘蛛爬虫，要每时每刻爬取互联网上最新的内容。<\/p>\n<p>一般的个人开发者都是用爬虫定向爬取一些网站，然后提取一些结构化的数据，使用api接口获取数据也可以归到这一类。如果想简单的练习爬虫技术，可以尝试爬取豆瓣电影数据和书籍数据的，使用api接口和爬取html页面都能完成这个任务。<\/p>\n<p>爬虫的说白了就是一个http客户端，通过http协议和远程http服务器通信，获取html页面内容或者其他的种子文件，pdf文件等等。和浏览器不同的一点就是爬虫不会把抓取的内容渲染出来，而是解析页面内容然后保存到数据库里面。<\/p>\n<p>在开始学习爬虫的时候我考虑的是怎么爬取html页面内容，怎么解析html页面之间的链接规则，后来遇到了页面编码的问题。<\/p>\n<h2>统一utf8编码<\/h2>\n<p>国内网站主要是使用html和gbk这两种编码方式，解决编码有两种思路，第一个是在获取页面内容的时候根据页面的<code>&lt;meta charset='gbk'&gt;<\/code>编码把内容统一转码成utf8的，因为nodejs字符串默认编码就是utf8。<\/p>\n<p><strong>这个方案充满了不确定性。<\/strong><\/p>\n<p>问题1：不同网站的指定编码的方式不一样，除了前面提到的那种方式，还有<code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gbk&quot;&gt;<\/code>这种方式指定编码，这个问题还不是很大，很多的http工具库都能正确的解析这两种编码，问题是还有很多网站没有指定编码，又或者指定的编码和文件的实际编码不一致（遇到过真实的案例）。<\/p>\n<p>问题2：如果你把gbk编码的html文件转成utf8编码保存到本地，用浏览器直接打开这个文件的时候会显示乱码，非常不利于开发过程中的查找问题。<\/p>\n<h2>不转码html内容<\/h2>\n<p>既然前面的方案有这么多的问题，剩下的方法就是把html内容直接按照原来的编码保存到本地，然后解析的时候指定编码。<\/p>\n<p>这个方法有2个好处：1、简化了爬虫模型，2、可以用浏览器打开html文件，不会乱码。唯一的缺点是不同网站文件内容解析的时候似乎需要指定编码，对于小规模爬虫这个问题其实影响不大。<\/p>\n<h2>统一爬虫模型<\/h2>\n<p>前面的编码方案解决了爬取不同网站html文件的编码问题，我们可以用一个统一的爬虫方法爬取不同网站的内容，那如果你想爬取非html内容呢？<\/p>\n<p>是不是又要重新写一个爬虫方法，解决这个问题的方法就是http协议，假设我们写的这个爬虫方法就是一个完整的http客户端，那理论上这个客户端是不是能根据<code>Content-Typ<\/code>获取各种格式的文件。<\/p>\n<p>那到底能不能用一个简单的方法就能实现上述的功能呢？下面的方法就是我采用request写的nodejs简单高效的爬虫模型。<\/p>\n<pre class=\"prettyprint\"><code>function fetch(url) {\n  console.log(&#96;down ${url} started&#96;);\n  const deferred = Q.defer();\n  const file = getfile(url);\n  fs.ensureDirSync(path.dirname(file));\n  const stream = request\n    .get(url)\n    .on(&#x27;error&#x27;, (err) =&gt; {\n      deferred.reject(&#96;down ${url}:${err}&#96;);\n    })\n    .on(&#x27;response&#x27;, (res) =&gt; {\n      if (res.statusCode !== 200) {\n        deferred.reject(&#96;down ${url}:${res.statusCode}&#96;);\n      } else {\n        console.log(&#96;down ${url}:${res.statusCode}&#96;);\n      }\n    })\n    .pipe(fs.createWriteStream(&#96;${file}&#96;));\n\n  stream.on(&#x27;finish&#x27;, () =&gt; {\n    deferred.resolve();\n  });\n  return deferred.promise;\n}\n<\/code><\/pre><p>这段代码在<code>yunshare/src/util/fetch.js<\/code>里面，当然这个方法不能单独运行，但是关键的逻辑就是这么简单。<\/p>\n<p>不管是什么格式的http请求，json，html，torrent等都统一把返回的二进制格式文件保存到以<code>md5(url)<\/code>为文件名的位置。上面的<code>getfile<\/code>就是用来获取文件路径的。<\/p>\n<h2>模型扩展<\/h2>\n<p>使用MD5散列还是有发生冲突的风险的，如果你想要爬取上亿的网页，可能还需要对上面的模型进行扩展。一个简单的思路就是把网页路径中的域名提取出来，不同网站的内容保存在对应的域文件夹下面。<\/p>\n<p>其他的类似的思路也行，需要注意的就是如果爬虫保存文件和解析文件是分开的，你需要保证在解析文件的时候能用同样的方法定位这个文件。共同的参数就是url，所以你生成文件名的时候不能用一些随时间变化的参数。<\/p>\n<p>最后，献上第一个使用node全栈开发的网站：<a href=\"http://www.biliworld.com/\">哔哩网盘搜索<\/a>，目前索引百度网盘资源1000w条了。<\/p>\n<\/div>","title":"简单高效的nodejs爬虫模型","last_reply_at":"2017-05-14T07:19:06.323Z","good":false,"top":false,"reply_count":25,"visit_count":3875,"create_at":"2016-12-09T02:34:16.729Z","author":{"loginname":"callmelanmao","avatar_url":"https://avatars.githubusercontent.com/u/4003337?v=3&s=120"}},{"id":"5917223bba8670562a40f0ad","author_id":"55b20cb7692e0e7706b366fd","tab":"share","content":"<div class=\"markdown-text\"><h2>项目说明<\/h2>\n<ul>\n<li>使用<strong>koa2.x<\/strong>，<strong>nodejs&gt;=7.6<\/strong>,<\/li>\n<li>使用<strong>async await<\/strong>解决异步，<\/li>\n<li>使用request-promise配合async await解决请求异步<\/li>\n<li>使用cheerio处理选择img标签<\/li>\n<\/ul>\n<h2>核心代码，spider.js<\/h2>\n<pre class=\"prettyprint language-js\"><code>const fs = require(&#x27;fs&#x27;);\nconst request = require(&quot;request-promise&quot;);\nconst cheerio = require(&quot;cheerio&quot;);\nconst mkdirp = require(&#x27;mkdirp&#x27;);\nconst config = require(&#x27;..&#x2F;config&#x27;);\n\nexports.download = async function(ctx, next) {\n    const dir = &#x27;images&#x27;;\n    &#x2F;&#x2F; 图片链接地址\n    let links = [];\n    &#x2F;&#x2F; 创建目录\n    mkdirp(dir);\n    var urls = [];\n    let tasks = [];\n    let downloadTask = [];\n    let url = config.url;\n    for (var i = 1; i &lt;= config.size; i++) {\n        let link = url + &#x27;_&#x27; + i + &#x27;.html&#x27;;\n        if (i == 1) {\n            link = url + &#x27;.html&#x27;;\n        }\n        tasks.push(getResLink(i, link))\n    }\n    links = await Promise.all(tasks)\n    console.log(&#x27;links==========&#x27;, links.length);\n\n    for (var i = 0; i &lt; links.length; i++) {\n        let item = links[i];\n        let index = item.split(&#x27;___&#x27;)[0];\n        let src = item.split(&#x27;___&#x27;)[1];\n        downloadTask.push(downloadImg(src, dir, index + links[i].substr(-4, 4)));\n    }\n    await Promise.all(downloadTask);\n}\nasync function downloadImg(url, dir, filename) {\n    console.log(&#x27;download begin---&#x27;, url);\n    request.get(url).pipe(fs.createWriteStream(dir + &quot;&#x2F;&quot; + filename)).on(&#x27;close&#x27;, function() {\n        console.log(&#x27;download success&#x27;, url);\n    });\n}\nasync function getResLink(index, url) {\n    const body = await request(url);\n    let urls = [];\n    var $ = cheerio.load(body);\n    $(config.rule).each(function() {\n        var src = $(this).attr(&#x27;src&#x27;);\n        urls.push(src);\n    });\n    return index + &#x27;___&#x27; + urls[0];\n}\n<\/code><\/pre><h3>代码地址，有需要可以看看<\/h3>\n<p><a href=\"https://github.com/maochunguang/koa-spider\">koa-spider代码地址<\/a><\/p>\n<h3>代码运行效果<\/h3>\n<p><img src=\"//dn-cnode.qbox.me/FsAnkB6oycRIBQ1_sOOITAXncgMp\" alt=\"GQ)PW}B)7UYH6LZ_SFE~AG7.png\"><\/p>\n<h3>下载美女图片的效果<\/h3>\n<p><img src=\"//dn-cnode.qbox.me/Fs_P5zEN8-VPoKUSnJdrjTteAIN6\" alt=\"test.png\"><\/p>\n<\/div>","title":"使用koa写一个漫画下载的爬虫","last_reply_at":"2017-05-14T07:18:27.782Z","good":false,"top":false,"reply_count":3,"visit_count":144,"create_at":"2017-05-13T15:11:55.280Z","author":{"loginname":"maochunguang","avatar_url":"https://avatars1.githubusercontent.com/u/11879404?v=3&s=120"}},{"id":"4f939c84407edba2143c12f7","author_id":"4f936f22407edba2143a4a60","content":"<div class=\"markdown-text\"><p>目前流行的\u201c你画我猜\u201d应用，你有没有想过使用HTML5来实现过？那么不可避免的需要解决canvas保存图片到硬盘或mongodb之类的数据库。本文主要介绍使用nodejs将html5 canvas base64编码图片保存为文件，同时提供两种解决方案。<\/p>\n<p>html5 canvas属于客户端API，没有权限去保存图片到硬盘，只有canvas . toDataURL()这一个接口可导出画布的base64编码，以提供给服务端进行处理保存，据我所知.net和php都有方法或类来进行简单的处理保存。nodejs呢？是的，没错！nodejs同样有能力来保存base64编码的图片。<\/p>\n<p><strong>解决方案一：<\/strong><\/p>\n<p>使用new Buffer来创建对应编码的缓冲，通过fs模块将Buffer写成一个文件。<\/p>\n<p>优点：简单易用，无需其它模块的支持。<\/p>\n<p>缺点：不能对图片的尺寸，水印，压缩，格式等进行处理。<\/p>\n<p>注意点：<\/p>\n<p>1、new Buffer接收到base64编码，不能带data:URL，而使用canvas . toDataURL()导出的base64编码会带data:URL，所以需要先过滤掉<\/p>\n<p>类似这样的一段\u201cdata:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0\u201d<\/p>\n<p>需过滤成：\u201ciVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0\u201d<\/p>\n<p>2、\u2019binary\u2019 \u2013 一种只使用每个字符前8个字节将原始的二进制数据编码进字符串的方式。这个方式已经废弃，应当尽量使用buffer 对象。这个编码将会在未来的node 中删除。<\/p>\n<p>看到有人把base64声明的Buffer再转换成binary，这个是完全没必要的。<\/p>\n<p>3、生成的图片有size变化，但是打开后是一个无效的图像，这个看本文的第三点。<\/p>\n<p><strong>使用express搭建的/upload (POST)上传保存接口，完成代码如下：<\/strong><\/p>\n<pre class=\"prettyprint\"><code>var express = require(&#x27;express&#x27;);\nvar fs = require(&quot;fs&quot;);\nvar app = module.exports = express();\n&#x2F;&#x2F;配置\napp.configure(function(){\n  app.use(express.bodyParser());\n  app.use(express.methodOverride());\n  app.use(express.cookieParser(&#x27;keyboard cat&#x27;));\n  app.use(express.session());\n  app.use(app.router);\n  app.use(express.static(__dirname + &#x27;&#x2F;up&#x27;)); &#x2F;&#x2F;静态文件目录\n  app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));\n});\n&#x2F;&#x2F;保存base64图片POST方法\napp.post(&#x27;&#x2F;upload&#x27;, function(req, res){\n\t&#x2F;&#x2F;接收前台POST过来的base64\n\tvar imgData = req.body.imgData;\n\t&#x2F;&#x2F;过滤data:URL\n\tvar base64Data = imgData.replace(&#x2F;^data:image\\&#x2F;\\w+;base64,&#x2F;, &quot;&quot;);\n\tvar dataBuffer = new Buffer(base64Data, &#x27;base64&#x27;);\n\tfs.writeFile(&quot;out.png&quot;, dataBuffer, function(err) {\n\t\tif(err){\n\t\t  res.send(err);\n\t\t}else{\n\t\t  res.send(&quot;保存成功！&quot;);\n\t\t}\n\t});\n});\nif (!module.parent) {\n  app.listen(8000);\n  console.log(&#x27;Express started on port 8000&#x27;);\n}\n<\/code><\/pre><p><strong>解决方案二：<\/strong><\/p>\n<p>使用node-canvas模块进行图片处理和保存。<\/p>\n<p>（node-canvas安装见我的另一篇博文：<a href=\"http://www.2fz1.com/?p=246\">http://www.2fz1.com/?p=246<\/a>）<\/p>\n<p>优点：能对图片像html5 canvas一样进行处理，尺寸调整、水印、图片反转色、格式转换<\/p>\n<p>缺点：需安装模块支持、当base64编码有误不能解析成图片时会报错并停止nodejs服务。<\/p>\n<p>注意点：canvas透明背景，默认为黑色；使用base64给img.src赋值时，需带上data:URL<\/p>\n<p><strong>使用express搭建的/upload (POST)上传保存接口，完成代码如下：<\/strong><\/p>\n<pre class=\"prettyprint\"><code>var Canvas = require(&#x27;canvas&#x27;); &#x2F;&#x2F;需安装canvas模块\nvar express = require(&#x27;express&#x27;);\nvar fs = require(&quot;fs&quot;);\nvar app = module.exports = express();\n&#x2F;&#x2F;配置\napp.configure(function(){\n  app.use(express.bodyParser());\n  app.use(express.methodOverride());\n  app.use(express.cookieParser(&#x27;keyboard cat&#x27;));\n  app.use(express.session());\n  app.use(app.router);\n  app.use(express.static(__dirname + &#x27;&#x2F;up&#x27;)); &#x2F;&#x2F;静态文件目录\n  app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));\n});\n\napp.post(&#x27;&#x2F;upload&#x27;, function(req, res){\n\tvar base64Data = req.body.imgData;\n\tvar img = new Canvas.Image;\n\n\timg.onload = function(){\n\t\tvar w = img.width;\n\t\tvar h = img.height;\n\t\tvar canvas = new Canvas(w, h);\n\t\tvar ctx = canvas.getContext(&#x27;2d&#x27;);\n\t\tctx.drawImage(img, 0, 0);\n\n\t\tvar out = fs.createWriteStream(__dirname + &#x27;&#x2F;crop.jpg&#x27;);\n\t\tvar stream = canvas.createJPEGStream({\n\t\t\tbufsize : 2048,\n\t\t\tquality : 80\n\t\t});\n\n\t\tstream.on(&#x27;data&#x27;, function(chunk){\n\t\t\tout.write(chunk);\n\t\t});\n\n\t\tstream.on(&#x27;end&#x27;, function(){\n\t\t\tout.end();\n\t\t\tres.send(&quot;上传成功！&quot;);\n\t\t});\n\t}\n\n\timg.onerror = function(err){\n\t\tres.send(err);\n\t}\n\n\timg.src = base64Data;\n});\nif (!module.parent) {\n  app.listen(8000);\n  console.log(&#x27;Express started on port 3000&#x27;);\n}\n<\/code><\/pre><p><strong>容易出现的错误（base64编码中，不容忽视的\u201c+\u201d号）<\/strong><\/p>\n<p>1、如果canvas没有任何像素，则返回值为：\u201cdata:,\u201d，这是最短的data:URL，代码中最好做一下保护。<\/p>\n<p>2、使用解决方案一实现图片保存，生成的图片有size，但是打开后却是不能识别的无效图像。<\/p>\n<p>使用解决方案二实现图片保存，nodejs直接报错，并且服务挂掉。<\/p>\n<p><strong>原因：<\/strong><\/p>\n<p>这个问题，花了我很长时间才找到原因，根本原因是base64编码，使用express接收POST值后，base64编码字符串中的\u201c+\u201d号被替换成空格了，引起编码出错，img.src = base64Data;直接把nodejs服务挂掉。如果你出现类似问题，请console.log(base64Data);看字符串是否有空格。<\/p>\n<p><strong>解决办法：<\/strong><\/p>\n<p>将空格替换回\u201c+\u201d号<\/p>\n<pre class=\"prettyprint\"><code>var base64Data = imgData.replace(&#x2F;\\s&#x2F;g,&quot;+&quot;);\n<\/code><\/pre><\/div>","title":"使用nodejs将html5 canvas base64编码图片保存为文件","last_reply_at":"2017-05-14T06:00:26.160Z","good":false,"top":false,"reply_count":7,"visit_count":29827,"create_at":"2012-04-22T05:52:04.906Z","author":{"loginname":"zzyss86","avatar_url":"//gravatar.com/avatar/b84fad7b74c7f1384aa9ed09fbed2671?size=48"}},{"id":"59145eb6ba8670562a40ef61","author_id":"575fc3cce8689e7906af736f","tab":"share","content":"<div class=\"markdown-text\"><p>刚花了两天时间做了个粗糙的小说阅读器，期待有兴趣的 XD 一起完善^_^\n项目地址： <a href=\"https://github.com/winglight/soducrawler\">https://github.com/winglight/soducrawler<\/a><\/p>\n<p>下面是介绍：<\/p>\n<h1>搜读阅读器<\/h1>\n<h2>这个项目是为了解决阅读网络小说的几个痛点：<\/h2>\n<ul>\n<li>\u201c免费\u201d网站广告太多<\/li>\n<li>有些不能收藏，有些能，但是有 bug，或者有收藏数量限制<\/li>\n<li>阅读不便，总是要弹开新窗口<\/li>\n<li>追更新不便，需要手动刷新<\/li>\n<li>不能在 PC 和手机之间同步进度<\/li>\n<li>不能离线查看<\/li>\n<\/ul>\n<h2>因此，这个项目的路线图如下：<\/h2>\n<ul>\n<li>抓取网络小说及章节内容（ DONE ）<\/li>\n<li>展示小说列表（ DONE ）<\/li>\n<li>小说章节阅读器（ TODO ）<\/li>\n<li>本地收藏（ TODO ）<\/li>\n<li>云端同步收藏、进度信息（ TODO ）<\/li>\n<li>封装 electron 客户端（ TODO ）<\/li>\n<li>APP 版（ TODO ）<\/li>\n<\/ul>\n<h2>本地安装使用方法：<\/h2>\n<ol>\n<li>安装 nodejs 环境<\/li>\n<li>安装 node 依赖包：在命令行进入项目目录，执行<\/li>\n<\/ol>\n<blockquote>\n<p>npm install<\/p>\n<\/blockquote>\n<p>或者，使用 yarn<\/p>\n<blockquote>\n<p>yarn<\/p>\n<\/blockquote>\n<ol>\n<li>执行抓取代码<\/li>\n<\/ol>\n<blockquote>\n<p>node crawler.js<\/p>\n<\/blockquote>\n<ol>\n<li>打开小说阅读器：直接双击 index.html 在浏览器打开<\/li>\n<\/ol>\n<hr>\n<p>请注意，由于使用了 ng-admin 来自动生成阅读器页面，目前还有些展示问题：<\/p>\n<ol>\n<li>搜索小说必须使用全部名称<\/li>\n<li>查看章节内容时，html 标签全部显示出来了，而且字体太小<\/li>\n<li>显示章节列表时，打开 modal 窗口显示章节内容的功能还有问题：要么无法显示内容，要么显示带 html 标签的内容<\/li>\n<\/ol>\n<h2>项目采用了以下技术：<\/h2>\n<ol>\n<li>parse-server: <a href=\"https://github.com/ParsePlatform/parse-server-example\">https://github.com/ParsePlatform/parse-server-example<\/a><\/li>\n<li>ng-admin: <a href=\"https://www.gitbook.com/book/marmelab/ng-admin/details\">https://www.gitbook.com/book/marmelab/ng-admin/details<\/a><\/li>\n<li>cheerio: <a href=\"https://github.com/cheeriojs/cheerio\">https://github.com/cheeriojs/cheerio<\/a><\/li>\n<li>js-crawler: <a href=\"https://github.com/antivanov/js-crawler\">https://github.com/antivanov/js-crawler<\/a><\/li>\n<li>heroku: <a href=\"https://www.heroku.com\">https://www.heroku.com<\/a><\/li>\n<li>nodejs: <a href=\"https://nodejs.org\">https://nodejs.org<\/a><\/li>\n<li>其他使用到的开源项目，请看 package.json<\/li>\n<\/ol>\n<h3>欢迎大家提出宝贵意见，反馈直接发到 issue，有兴趣参与开发的可以提 pull request，我会尽快处理。<\/h3>\n<p>能看到这里的都是真爱：其实我是碰到难题一时没有办法，诚邀 nodejs/angularjs 高手来解决！<\/p>\n<\/div>","title":"有喜欢看小说的程序员进来看看","last_reply_at":"2017-05-14T05:54:47.757Z","good":false,"top":false,"reply_count":8,"visit_count":423,"create_at":"2017-05-11T12:53:10.846Z","author":{"loginname":"winglight","avatar_url":"https://avatars2.githubusercontent.com/u/1176967?v=3&s=120"}},{"id":"5917eb99d371b6372a8af997","author_id":"5916cc97d371b6372a8af96e","tab":"ask","content":"<div class=\"markdown-text\"><p>vue-cli的热加载怎么打开？运行了<\/p>\n<blockquote>\n<p>npm run build<\/p>\n<\/blockquote>\n<p>后就不能用热加载了？请问怎么解决<\/p>\n<\/div>","title":"vue-cli的热加载","last_reply_at":"2017-05-14T05:54:09.703Z","good":false,"top":false,"reply_count":1,"visit_count":31,"create_at":"2017-05-14T05:31:05.486Z","author":{"loginname":"YuJiusihuanian","avatar_url":"https://avatars0.githubusercontent.com/u/21097145?v=3&s=120"}},{"id":"549430f49b158a790e21dc99","author_id":"5360612d469fb3112c003f63","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FoBrJyxtpqwZXG2ZMfbI4sS3RCYO\" alt=\"async.jpg\"><\/p>\n<blockquote>\n<p>由于<a href=\"http://yijiebuyi.com/blog/8e86c479d2d290f98c1d1581a61f1396.html\">node.js的异步io,事件驱动回调<\/a>等特性,导致大部分刚刚接触node.js的工程师每天困扰在多函数嵌套,异步执行顺序等问题上.\n所以async 作为大名鼎鼎的异步控制流程包,<a href=\"http://xn--npmjs-8w2i.org\">在npmjs.org<\/a> 排名稳居前五,目前已经逐渐形成<a href=\"http://yijiebuyi.com\">node.js<\/a>下控制异步流程的一个规范.<a href=\"http://yijiebuyi.com/blog/be234394cd350de16479c583f6f6bcb6.html\">async成为异步编码流程控制<\/a>的老大哥绝非偶然,它不仅使用方便,文档完善,把你杂乱无章的代码结构化,生辰嵌套的回掉清晰化.\nasync 提供的api包括三个部分:<\/p>\n<\/blockquote>\n<h4>(1)流程控制 常见的几种流程控制.<\/h4>\n<h4>(2)集合处理 异步操作处理集合中的数据.<\/h4>\n<h4>(3)工具类 .<\/h4>\n<blockquote>\n<blockquote>\n<p>github 开源地址:<a href=\"https://github.com/caolan/async\">https://github.com/caolan/async<\/a>\n<code>安装方法: npm install async<\/code>\n使用方法:\n<code>var async=require('async');<\/code><\/p>\n<\/blockquote>\n<\/blockquote>\n<h3>串行且无关联<\/h3>\n<blockquote>\n<blockquote>\n<p>话句话说就是按照顺序执行,一个一个来,无关联就是值前一个callback回来的值不是后一步执行的条件\n场景:提取某学校大三学生的学生信息(假设每个班级存储在一个独立的数据表里)\n分析:每个班级的学生之间是无关联的,假设共有3个班级,我们需要遍历3个表,把提取出的学生信息返回客户端一个json,如下<\/p>\n<\/blockquote>\n<\/blockquote>\n<pre class=\"prettyprint\"><code>{\n&quot;1班&quot;:[{name:&quot;张三&quot;,age:&quot;21&quot;,class:&quot;1班&quot;},......(省略N个学生)]\n&quot;2班&quot;:[{name:&quot;李四&quot;,age:&quot;22&quot;,class:&quot;2班&quot;},......(省略N个学生)]\n&quot;3班&quot;:[{name:&quot;王五&quot;,age:&quot;22&quot;,class:&quot;3班&quot;},......(省略N个学生)]\n}\n<\/code><\/pre><blockquote>\n<p>如果不使用 async ,你也许只好挣扎在一堆大括号中<\/p>\n<\/blockquote>\n<pre class=\"prettyprint\"><code>var class=require(&#x27;.&#x2F;module&#x2F;class&#x27;);\nexport.pageStudent=function(req,res){\nvar rtnJson={};\n    class.getStudent(&#x27;1班&#x27;,function(error,oneResult){\n        if(!error&amp;&amp;oneResult){\n            rtnJson[&#x27;1班&#x27;]=oneResult;\n            class.getStudent(&#x27;2班&#x27;,function(error,twoResult){\n                if(!error&amp;&amp;twoResult){\n                    rtnJson[&#x27;2班&#x27;]=twoResult;\n                    class.getStudent(&#x27;3班&#x27;,function(error,threeResult){\n                        if(!error&amp;&amp;threeResult){\n                            rtnJson[&#x27;3班&#x27;]=threeResult;\n                            &#x2F;&#x2F;3个班级全部获取完成\n                            res.render(&#x27;.&#x2F;veiw&#x2F;pageStudent&#x27;,{students:rtnJson});\n                        }else{\n                            res.render(&#x27;.&#x2F;veiw&#x2F;pageStudent&#x27;,{students:rtnJson});\n                        }\n                    });\n                }else{\n                    res.render(&#x27;.&#x2F;veiw&#x2F;pageStudent&#x27;,{students:rtnJson});\n                }\n            });\n        }else{\n            res.render(&#x27;.&#x2F;veiw&#x2F;pageStudent&#x27;,{students:rtnJson});\n        }\n    });\n}\n<\/code><\/pre><blockquote>\n<p>看上去是不是很想吐的感觉?? 如果更多的班级出现,你用上面的方法估计会让你七窍流血,晕死在电脑桌前,\n先了解一下async串行无关联方法<\/p>\n<\/blockquote>\n<pre class=\"prettyprint\"><code>async.series({\n  flag1:function(done){ &#x2F;&#x2F;flag1 是一个流程标识,用户自定义\n      &#x2F;&#x2F;逻辑处理\n      done(null,返回结果)&#x2F;&#x2F; 第一个参数是异常错误,第二个参数的返回结果\n  },\n  flag2:function(done){\n      &#x2F;&#x2F;逻辑处理\n      done(&#x27;error info&#x27;,null) &#x2F;&#x2F;如果返回错误信息,\n                              &#x2F;&#x2F;下面的流程控制将会被中断,直接跳到最后结果函数\n  },\n},function(error,result){\n    &#x2F;&#x2F;最后结果\n    &#x2F;&#x2F;result是返回结果总集,包含了所有的流程控制 ,\n    &#x2F;&#x2F;result.flag1 可以获取标识1中处理的结果\n});\n<\/code><\/pre><blockquote>\n<p>对照上面的注释说明了解一下,然后我们把上面一大堆回调大括号的代码用async series方法改进一下<\/p>\n<\/blockquote>\n<pre class=\"prettyprint\"><code>async.series({\n    oneClass:function(done){\n        class.getStudent(&#x27;1班&#x27;,function(error,oneResult){\n            if(!error)\n                done(null,oneResult);\n            else\n                done(error,null);\n        });\n    },\n    twoClass:function(done){\n        class.getStudent(&#x27;2班&#x27;,function(error,twoResult){\n            if(!error)\n                done(null,twoResult);\n            else\n                done(error,null);\n        }\n    },\n    threeClass:function(done){\n        class.getStudent(&#x27;3班&#x27;,function(error,threeResult){\n            if(!error)\n                done(null,threeResult);\n            else\n                done(error,null);\n        }\n    }\n},function(error,result){\n    if(!error)\n        callback(null,result);\n    else\n        callback(error,null);\n});\n<\/code><\/pre><blockquote>\n<p>上面是一个标准的串行流程,代码可读性很强, 容易维护,但是这种流程只适合按顺序执行且每一步没有关联\n如果你的业务逻辑是根本不需要按顺序执行的,比如获取不同班级的信息,其实先获取1班和先获取3班是一样的,只要最后结果保证3个班的人员信息都获取成功即可.所以这里用series 是一种错误,反而和 node.js 的异步IO相互矛盾.应该用 并行且无关联的控制流程.\n串行无关联模式要求每一步执行成功后才能执行下一步流程.<\/p>\n<\/blockquote>\n<h3>并行且无关联<\/h3>\n<blockquote>\n<p>场景如上,获取4个班级学生信息.\nasync 里的提供的并行无关联 api 是 parallel\nparallel 的原理是同时并行处理每一个流程,最后汇总结果,如果某一个流程出错就退出.把获取班级成员信息的代码用 parallel 来实现如下<\/p>\n<\/blockquote>\n<pre class=\"prettyprint\"><code>async.parallel({\n    oneClass:function(done){\n        class.getStudent(&#x27;1班&#x27;,function(error,oneResult){\n            if(!error)\n                done(null,oneResult);\n            else\n                done(error,null);\n        });\n    },\n    twoClass:function(done){\n        class.getStudent(&#x27;2班&#x27;,function(error,twoResult){\n            if(!error)\n                done(null,twoResult);\n            else\n                done(error,null);\n        }\n    },\n    threeClass:function(done){\n        class.getStudent(&#x27;3班&#x27;,function(error,threeResult){\n            if(!error)\n                done(null,threeResult);\n            else\n                done(error,null);\n        }\n    }\n},function(error,result){\n    if(!error)\n        callback(null,result);\n    else\n        callback(error,null);\n});\n<\/code><\/pre><blockquote>\n<p>看上去并行和串行仅仅是一个关键词的变化,其实他们的运行机制完全不同,并行无关联是全部业务流程一起进行,最后一个执行完直接返回结果,而不像上面的串行方法必须一个一个等待执行.<\/p>\n<\/blockquote>\n<h3>串行且有关联<\/h3>\n<blockquote>\n<p>场景:打开微博首页需要加载 微博个人信息,微博分组信息,微博分组粉丝信息 这里不考虑ajax 异步拉取每个模块.如果我们用ejs来渲染,需要发送给前端页面一个这样的数据结构(简单的模拟数据)<\/p>\n<\/blockquote>\n<pre class=\"prettyprint\"><code>{\nuserInfo:{userID:10001,totalNum:368,fans:562,follow:369}\ngroup:[{groupID:100,groupName:&quot;粉丝&quot;},{groupID:200,groupName:&quot;同事&quot;}...],\nfansGroup:{&quot;粉丝&quot;:[{nickName:&#x27;aa&#x27;,age:20},{nickName:&#x27;bb&#x27;,age:22}....]}\n}\n<\/code><\/pre><blockquote>\n<p>上面的信息取自3个不同的表,但是每一个流程都和上一个流程有关系,也就是说,如果拿到用户信息后,根据用户ID 获取此微博用户的分组,根据分组ID获取每个组里面的粉丝.一环扣一环,希望流程按顺序执行,且每一步逻辑控制都能由上一步得到的结果来做条件.\n再来个传统的嵌套 ^_^<\/p>\n<\/blockquote>\n<pre class=\"prettyprint\"><code>var userInfo=require(&#x27;.&#x2F;lib&#x2F;module&#x2F;userInfo&#x27;);\nvar group=require(&#x27;.&#x2F;lib&#x2F;module&#x2F;group&#x27;);\nvar groupFans=require(&#x27;.&#x2F;lib&#x2F;module&#x2F;groupFans&#x27;);\n&#x2F;&#x2F;传统嵌套代码如下\nexport.pageIndex=function(req,res){\n    userInfo.get(userEmail,passWord,function(error,userInfo){\n         group.get(userInfo.userID,function(error,groupList){\n             var idx=0,fansList=[];\n             for(var i=0;i&lt;groupList.length;i++){\n                 groupFans.get(groupList[idx++],function(error,fansInfo){\n                     fansList.push(fansInfo);\n                     if(idx==groupList.length){\n                         callback(null,{userInfo:userInfo,group:groupList,fansGroup:fansList});\n                     }\n                 })\n             }    \n         });\n    });\n}\n<\/code><\/pre><blockquote>\n<p>上面的代码互相牵扯关系,每一步的逻辑运算都需要上一步的结果来支持,我们假设每一步都运行正确,没有对error 进行判断.\n最后因为要遍历数组中元素,然后把每个元素对应的分组成员都组合起来,我们用到了数据索引计数器 idx,上面的代码看似没有问题,但是索引计数器非常不好控制,稍有差错可能会不运行.\nanync 的waterfall 适合上面的场景.\nwaterfall 每一步执行时需要由上一步执行的结果当做参数.所以每一步必须串行等待.事例代码如下:<\/p>\n<\/blockquote>\n<pre class=\"prettyprint\"><code>console.time(&#x27;waterfall&#x27;);\nasync.waterfall([\n    function (done) {\n        done(null, &#x27;one&#x27;);\n    },\n    function (onearg, done) {\n        done(null, onearg + &#x27;| two&#x27;);\n    },\n    function (twoarg, done) {\n\n        done(null, twoarg + &#x27;| three&#x27;);\n    },\n    function (threearg, done) {\n        done(null, threearg + &#x27;| four&#x27;);\n    }\n], function (error, result) {\n    console.log(result);\n    console.timeEnd(&#x27;waterfall&#x27;);\n})\n<\/code><\/pre><blockquote>\n<p>上面调用 waterfall 函数时传入一个数组,数组总的每一个元素就是一个串行控制节点,每一个节点执行必须保证上一节点已经执行完成且拿到结果.这样将结果传入下一个控制节点作为参数来运行.\n参数数组第一个元素回调函数 done(null,\u2018one\u2019) --&gt;null 说明执行没有错误, \u2018one\u2019 是第一个节点运行返回的结果(这个结果将会传入第二个控制流程来作为参数)\u2026这样以此类推,最后一个元素(第四个)返回的结果应该是 'one|tow|three|four \u2019 这个字符串,也就是 result 打印出的内容.<\/p>\n<\/blockquote>\n<h4>注意<\/h4>\n<blockquote>\n<p>async 提供的api默认支持多种传递参数的写法,我个人比较喜欢用对象表示法来传递( json格式) 但是waterfall 这个api很特殊,不支持对象参数,如果你用下面的错误代码来调用 waterfall 的话,你不会拿到运行结果.<\/p>\n<\/blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;此调用方法是错误的!!!\nconsole.time(&#x27;waterfall&#x27;);\nasync.waterfall({\n    one: function (done) {\n        &#x2F;&#x2F;处理逻辑\n        done(null, &#x27;one&#x27;);\n    },\n    two: function (onearg, done) {\n        &#x2F;&#x2F;处理逻辑\n        console.log(&#x27;-----&#x27;, onearg);\n        done(null, onearg + &#x27;two&#x27;);\n    },\n    three: function (twoarg, done) {\n        &#x2F;&#x2F;处理逻辑\n        done(null, twoarg + &#x27;three&#x27;);\n    },\n    four: function (threearg, done) {\n        &#x2F;&#x2F;处理逻辑\n        done(null, threearg + &#x27;four&#x27;);\n    }\n}, function (error, result) {\n    console.log(result);\n    console.timeEnd(&#x27;waterfall&#x27;);\n})\n<\/code><\/pre><h4>注意上面是错误的写法,waterfall 很特殊,不支持这样的写法,只能用上面数组传递参数的形式.<\/h4>\n<p>还有很多要介绍的,后续再补吧,祝大家周末愉快!<\/p>\n<\/div>","title":"async解决异步IO回调困扰 - 串行 - 并行方法简介","last_reply_at":"2017-05-14T05:20:58.856Z","good":true,"top":false,"reply_count":12,"visit_count":3245,"create_at":"2014-12-19T14:06:44.895Z","author":{"loginname":"zzhi191","avatar_url":"https://avatars.githubusercontent.com/u/4724019?v=3&s=120"}},{"id":"591595989e32cc84569a6ee9","author_id":"54bdc3a8514ea9146862ac1e","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，代码如下：<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FotK9itDBNJzAvwAein6gNH7B3FB\" alt=\"image.png\"><\/p>\n<p>结果：<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FodtmwjYyg8QTdUbmDBTA87_CKjX\" alt=\"image.png\"><\/p>\n<p>babel配置：<\/p>\n<pre class=\"prettyprint language-javascript\"><code>{\n    &quot;presets&quot;: [\n        [&quot;es2015&quot;, {&quot;modules&quot;: false}],\n        [&quot;stage-3&quot;]\n    ],\n    &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;]\n}\n<\/code><\/pre><p>求教大神，这要怎么搞才行。。。<\/p>\n<\/div>","title":"Vue2 的JSX spread操作符不起作用","last_reply_at":"2017-05-14T05:06:00.450Z","good":false,"top":false,"reply_count":1,"visit_count":134,"create_at":"2017-05-12T10:59:36.687Z","author":{"loginname":"Ang-Work","avatar_url":"https://avatars1.githubusercontent.com/u/7222921?v=3&s=120"}},{"id":"50ec17ad5daa681f0a33afda","author_id":"505c207410ccdf807706d44a","content":"<div class=\"markdown-text\"><p>接触NodeJS已经有一段时间了，书看了不少，实践太少，今天突然想起要重温一下基础知识。鉴于自己平时喜欢php+mysql的组合，一时兴起就像弄一个node加mysql的例子。于是开始四处搜罗资料，本以为是一件很简单的事情，却不想其中是波折连连。<\/p>\n<p>首先，安装nodejs的mysql包这个就不多说了：<\/p>\n<pre class=\"prettyprint\"><code>npm install mysql\n<\/code><\/pre><p>接下来其实思路很简单，说白了就是连接mysql\u2014\u2014选择数据库\u2014\u2014执行sql语句，但是当我按照网上的资料开始动手写起来的时候，却发现效果不能出现，命令行错误一堆，mysql死活连接不上。于是我开始慌了，然后慢慢平静，开始一行一行查看代码，网上多表明链接数据库使用<code>require(&quot;mysql&quot;).Client<\/code>，我也就照这么做了，所以也就不行了。<\/p>\n<p>后来想了一个土办法，首先在mysql安装正确的前提下<code>require(&quot;mysql&quot;)<\/code>肯定是没有问题的，然后打印出改模块下的所有对象或属性<code>console.log(require(&quot;mysql&quot;))<\/code>，这下一目了然了，一看就找不到<code>Client<\/code>方法，仔细一瞧发现有个<code>createConnection<\/code>的方法，于是望文生义就开始使用这个方法尝试连接mysql，果不其然一下就OK了，具体如下：<\/p>\n<pre class=\"prettyprint\"><code>var mq = require(&quot;mysql&quot;);\nvar mc = mq.createConnection({\n    user: &quot;root&quot;,\n    password: &quot;xxxxxx&quot;\n});\nmc.connect();\n<\/code><\/pre><p>回头再想想，为什么网上搜罗的方法会失效呢？也许是因为版本更新的原因，有些方法名称也更换了。接下来就是简单的操作数据库了，与其他语言无异：<\/p>\n<pre class=\"prettyprint\"><code>mc.query(&quot;use database&quot;);\nmc.query(&quot;select * from table&quot;, function(err, rs, fields){\n    &#x2F;&#x2F;处理数据\n});\n<\/code><\/pre><p>好了，至此我的基本目的也就差不多实现了。<\/p>\n<\/div>","title":"NodeJS与MySql的相关操作","last_reply_at":"2017-05-14T04:56:07.370Z","good":false,"top":false,"reply_count":8,"visit_count":16675,"create_at":"2013-01-08T12:57:17.909Z","author":{"loginname":"mailzwj","avatar_url":"https://avatars2.githubusercontent.com/u/1563970?v=3&s=120"}},{"id":"59143cf63504ce1c2ac45ae1","author_id":"586efd62e05ad9c306275087","tab":"ask","content":"<div class=\"markdown-text\"><p>function checkFilesChanges() {\nlet checkFileDirectories = \u2018C:/images\u2019;\nlet oldFile=null;\nfs.watch(checkFileDirectories, (e, filename) =&gt; {\nif(e === \u2018rename\u2019) {\n\toldFile=filename;\nconsole.log(oldFile,filename)\n}\n})\n}<\/p>\n<p>为什么我这段代码,我新增了一个文件,能监视到\u2026但是如果我修改了文件 会执行2次,就修改以前的名称,修改之后的名称,都会返回来.怎么才能知道他是从哪个文件修改到哪个文件呢?<\/p>\n<p>比如我从1.txt,修改名称为2.txt  效果写不出来啊!!!<\/p>\n<\/div>","title":"关于nodejs  fs.watch监视文件变化的疑问!","last_reply_at":"2017-05-14T03:43:32.042Z","good":false,"top":false,"reply_count":4,"visit_count":281,"create_at":"2017-05-11T10:29:10.731Z","author":{"loginname":"caihuattkl","avatar_url":"https://avatars1.githubusercontent.com/u/18523369?v=3&s=120"}},{"id":"5916c2499e32cc84569a6f36","author_id":"5916c0be9e32cc84569a6f34","tab":"job","content":"<div class=\"markdown-text\"><p>职位诱惑：\n弹性工作,高成长,JS全栈,高提成\n职位描述：\n岗位要求：\n 1、精通Javascript语言与开发环境，对JS全栈开发有浓厚的兴趣\n 2、熟悉计算机体系结构、数据结构、算法\n 3、精通Node.js后端开发，使用过Express、KOA等至少一个后端框架\n 4、熟悉js前端开发，使用过Angular、Vue、React等至少一个前端框架\n 5、学习能力强，善于沟通，爱好编程，励志成为一个全栈工程师\n 6、有较强的主动性、责任心与执行能力，能够适应小团队单兵协同作战；\n 7、有过实际项目开发经验的优先，<\/p>\n<p>岗位职责：\n 1、负责使用js工具栈开发产品核心架构\n 2、负责使用js开发产品前后端核心逻辑<\/p>\n<p>关于福利：\n提供股份、项目提成、目标导向弹性工作，只要您是人才，将有机会成为公司合伙人享受公司成长收益。\n包中餐，试用期过可包住<\/p>\n<p>人才期望：\n我希望你是潜力股，正在寻找大展身手的平台，你就是我们正在寻找的人。\n工作地址\n深圳市罗湖区宝安北路口梅园仓库10号\n联系方式\n微信loveholding 186-1709-2100 (手机号)  邮箱：31317602@qq.com<\/p>\n<\/div>","title":"【深圳罗湖】10k-15k求全栈+五险+包吃+LOL+干股","last_reply_at":"2017-05-14T03:28:35.785Z","good":false,"top":false,"reply_count":1,"visit_count":76,"create_at":"2017-05-13T08:22:33.395Z","author":{"loginname":"akong12138","avatar_url":"https://avatars3.githubusercontent.com/u/28669282?v=3&s=120"}},{"id":"590311febbaf2f3f569be3d3","author_id":"59006da0bbaf2f3f569be2f2","tab":"share","content":"<div class=\"markdown-text\"><p>Vue 全家桶写的 CNode 社区，最好看的CNode社区！\n功能：首页、详情页、用户中心、消息页、发布话题\n技术栈：vue2+vuex+vue-router\n脚手架：vue-cli\n持续更新中，欢迎 fork/star。\ndemo： <a href=\"https://www.ldsun.com/vue-cnode\">https://www.ldsun.com/vue-cnode<\/a>\nGitHub： <a href=\"https://github.com/flute/vue-cnode\">https://github.com/flute/vue-cnode<\/a><\/p>\n<\/div>","title":"vue全家桶版CNode，可能是最好看的CNode","last_reply_at":"2017-05-14T01:52:54.609Z","good":false,"top":false,"reply_count":12,"visit_count":1058,"create_at":"2017-04-28T09:57:18.009Z","author":{"loginname":"flute","avatar_url":"https://avatars0.githubusercontent.com/u/5842406?v=3&s=120"}},{"id":"591700ddba8670562a40f0ac","author_id":"58c409cf79f557ff16f0f227","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，查找数据库中某个字段最值得数据，\n试了一下，find({$max:\u2018pv\u2019})；\n没反应，pv是一个字段，number型<\/p>\n<\/div>","title":"mongoose中怎么查找某个字段的最值，（最大最小值）的数据，网上没找到","last_reply_at":"2017-05-13T19:40:53.005Z","good":false,"top":false,"reply_count":4,"visit_count":110,"create_at":"2017-05-13T12:49:33.239Z","author":{"loginname":"HeroBoyluck","avatar_url":"https://avatars3.githubusercontent.com/u/23008329?v=3&s=120"}},{"id":"5916bce9ba8670562a40f0a2","author_id":"57c44e80a6539d652557521d","tab":"ask","content":"<div class=\"markdown-text\"><p>支付宝签名的时候是对请求的所有参数进行加密吗，包括sing和sing_type吗，然后再对sing的值进行替换？还有RSA加密是用crypto？这个库能用RSA2吗？\n哪位大佬能给个demo例子，微信已经搞定了就差支付宝了，十分感谢啊。<\/p>\n<\/div>","title":"nodejs 支付宝签名求助","last_reply_at":"2017-05-13T10:31:20.593Z","good":false,"top":false,"reply_count":4,"visit_count":118,"create_at":"2017-05-13T07:59:37.353Z","author":{"loginname":"zoobop","avatar_url":"https://avatars2.githubusercontent.com/u/17919872?v=3&s=120"}},{"id":"56679f2b5af0e6ab3bf1a189","author_id":"56679edc5af0e6ab3bf1a188","tab":"ask","content":"<div class=\"markdown-text\"><p>RT<\/p>\n<\/div>","title":"其他项目的模块能直接拷贝过来用吗？新人求问","last_reply_at":"2017-05-13T09:43:58.418Z","good":false,"top":false,"reply_count":4,"visit_count":672,"create_at":"2015-12-09T03:25:31.603Z","author":{"loginname":"PerfectDemo","avatar_url":"https://avatars2.githubusercontent.com/u/16203591?v=3&s=120"}},{"id":"5916bc92ba8670562a40f0a1","author_id":"5916ada33504ce1c2ac45bf8","tab":"ask","content":"<div class=\"markdown-text\"><p>测试 JS\nconsole.log(\u2018111111111\u2019);\nconsole.log(\u2018111111111\u2019);<\/p>\n<p>console.log(\u20181111\\n\\r11111\u2019);\ncmd 下好好的換行\nxshell 下 沒有自動 return 只有 換行<\/p>\n<p><img src=\"//dn-cnode.qbox.me/FmTmSJ0vye3PUBXS-nO5ArtxYvLy\" alt=\"image.png\"><\/p>\n<p>有没有什麽建议<\/p>\n<\/div>","title":"windows 下用 XSHELL 5 跑 node console.log 不换行问题","last_reply_at":"2017-05-13T07:58:10.667Z","good":false,"top":false,"reply_count":0,"visit_count":84,"create_at":"2017-05-13T07:58:10.667Z","author":{"loginname":"aaron-hsu","avatar_url":"https://avatars1.githubusercontent.com/u/5462413?v=3&s=120"}},{"id":"55cc0b51b25bd72150842b79","author_id":"5493989461491ead0cc7c09c","tab":"ask","content":"<div class=\"markdown-text\"><p>现在用session设置了会话过期时间为一分钟，发现一分钟后没有过期，而且mongodb数据库里面的session文档里面的到期时间也不是自己设置的到期时间，而是少了7小时。请问是不是因为时区的问题。这个问题怎么解决呢。<\/p>\n<\/div>","title":"nodejs express 如何设置时区","last_reply_at":"2017-05-13T07:44:25.311Z","good":false,"top":false,"reply_count":3,"visit_count":3143,"create_at":"2015-08-13T03:13:21.854Z","author":{"loginname":"sw-wang","avatar_url":"https://avatars.githubusercontent.com/u/9412628?v=3&s=120"}},{"id":"5916b588ba8670562a40f0a0","author_id":"5916ada33504ce1c2ac45bf8","tab":"job","content":"<div class=\"markdown-text\"><p>一米市集\nPC版 <a href=\"https://www.yimishiji.com/\">https://www.yimishiji.com/<\/a>\n手机版 <a href=\"https://m.yimishiji.com/\">https://m.yimishiji.com/<\/a><\/p>\n<p>岗位职责：\nGrowth hacking 部门一员\n为了达到用户快速成长开发最小可行性方案进行实际实验\n对实验进行监看、分析、调整、结论<\/p>\n<p>目前用node.js建置MVP\n1、前端用React.js 实现；\n2、後端用Express加上其它loadash、Bluebird、RabbitMQ、MongoDB\u2026等依需求找可用的library；<\/p>\n<p>其它使用的第三方工具\n1、追踪:GA GTM HOTJAR\n2、分析:Tableau\n3、其它任何有帮助用户成长的工具<\/p>\n<p>任职要求：\n1、对新技术充满激情，学习能力强，需要一直學習新東西\n2、代码可读性放在首要位置\n3、本科以上学历，计算机相关专业毕业，1年以上开发经验；\n4、熟悉 Node.js 及 Express、loadash、Bluebird、RabbitMQ；\n5、了解熟悉关系数据库和 NoSQL 差异，如 Mongo 和 MySQL 等；\n6、熟悉 React；<\/p>\n<p>工作地址：\n上海 - 长宁区 \u2013 淞虹路 \u2013 天山西路789号中山国际广场B座2楼 (近2号線淞虹站)<\/p>\n<p>面试方法：\n面试需要上机考，写出你的超强实力，建议自带电脑<\/p>\n<p>联系方式：\n请发送简历至aaron.hsu@yimishiji.com，简历请注明来自CNODE<\/p>\n<\/div>","title":"【上海长宁】一米市集 node.js 一名 10-25K","last_reply_at":"2017-05-13T07:28:08.846Z","good":false,"top":false,"reply_count":0,"visit_count":56,"create_at":"2017-05-13T07:28:08.846Z","author":{"loginname":"aaron-hsu","avatar_url":"https://avatars1.githubusercontent.com/u/5462413?v=3&s=120"}},{"id":"58fe0a8d31e8c2bb1c3dcda8","author_id":"57df84493af3942a3aa3b881","tab":"job","content":"<div class=\"markdown-text\"><p>租房是我们大多数人都必须经历的小门槛，往往还让我们很头疼。这是一个古老而又重要的行业，我们相信未来租房一定不是现在这样的。<\/p>\n<p>暖房是我们在做一个新尝试：<a href=\"https://nuan.io\">https://nuan.io<\/a> | 公众号 nuanio<\/p>\n<p>帮助用户一步找遍豆瓣、 58 、赶集、搜房等网站的所有个人房源，🤖️ 让机器用智能算法和数据技术为我们筛选房子，甄别过滤中介和虚假房源，尽力把高质量房源直接呈现在用户面前。 希望很快暖房系统推荐的房子比中介更让人满意。<\/p>\n<p>我们是个产品技术驱动的团队，创始班底源自 Opera ，世界少数几家专业浏览器厂商。成员是做浏览器和分布式计算的产品技术牛人，有足够的驾驭复杂技术产品的能力。我们曾为中国用户从 10 万到千万级的增长做了绵薄贡献，但没达到十年前自己定下的亿级小目标，所以我们重新上路折腾。<\/p>\n<p>已经拿到充足初期投资，天使投资人本身是位非常厉害的创业者，除了给我们宝贵的经验，还将帮助我们引入顶级机构的投资\u2014\u2014前提当然是我们做出有价值的产品。<\/p>\n<h1>🙉 需求<\/h1>\n<p>我们不设特别固定的要求，更喜欢因人设岗，发挥每个人最大的价值。<\/p>\n<ul>\n<li>需要你是个聪明且勤奋的家伙<\/li>\n<li>有好奇心和创造精神，渴望用知识和能力解决生活中的基础问题<\/li>\n<li>既能独立工作，又懂得团队合作<\/li>\n<li>善用工具<\/li>\n<li>加分项：用 Emacs ；严重减分项：只用过 Windows<\/li>\n<\/ul>\n<h2>Web 全栈工程师<\/h2>\n<p>研发构建暖房的多个服务器系统：<\/p>\n<ul>\n<li>涉及的几方面技术按优先级排序： Web 系统架构（ Node.js 等）、搜索技术、爬虫技术。最希望你是这几方面都搞得定，但如果能在某一两方面特别擅长，我们也热烈欢迎！<\/li>\n<li>扎实的 CS 基础<\/li>\n<li>用动态语言做过靠谱的服务器程序（ Node.js / Python / Ruby ，甚至 Go / Pike / LISP 等）\u2014\u2014当然如果还接受过 C / C++ 的洗礼那就更棒了！<\/li>\n<li>有面向最终用户产品的研发经验，且希望你曾从产品的初创阶段就参与构建<\/li>\n<li>良好的工程思维<\/li>\n<\/ul>\n<p>此外浏览器研发的基因让我们深知 Web 技术作为基础技术的威力，这些杀器也在走出浏览器本身，以新的形态渗透到不同技术领域（比如 Node.js 、 React Native 、 Electron 等），我们对这些新形态有强烈兴趣，希望你也是。<\/p>\n<h2>数据挖掘工程师<\/h2>\n<p>研发构建甄别系统，过滤中介及虚假房源，筛选推荐高质量房源。<\/p>\n<ul>\n<li>具备以下一个或多个领域的经验和能力：数据挖掘 / 机器学习 / 反欺诈 / 推荐系统 / 自然语言处理 / 搜索技术<\/li>\n<li>敏锐的观察力和优秀的逻辑思维，善于洞察规律，抓住本质<\/li>\n<li>强大的动手能力，兼备优秀的算法设计和编码功底<\/li>\n<\/ul>\n<p>我们把反虚假和反欺诈作为暖房的责任（这本该是 58 等大玩家该承担的工作），并相信跟人肉眼相比，通过机器和数据判别中介将有巨大的优势。暖房已经初步进化出微小的能力，但远远还不够，希望你能帮助我们。<\/p>\n<h1>💰 给予<\/h1>\n<p>「如果没有你想要的工作环境，就自己创造一个」，这是我们所践行的：<\/p>\n<ul>\n<li>绝对有挑战的工作，独特的产品<\/li>\n<li>有诚意的薪资，大量早期股票期权<\/li>\n<li>非常重视 code review 、自动化测试和工具化运维<\/li>\n<li>关乎团队效率和爽感的投入绝不吝啬， MacBook Pro 、正版开发工具、内部工具等等，反正机器能干的事就一定让机器干<\/li>\n<li>考虑请位阿姨做饭，让大家吃得安心<\/li>\n<li>透明和 open 的工作方式<\/li>\n<li>最紧要开心！想尝试不同的工作挑战自己？想吐槽 CEO ？都没问题！随时倾听你的任何意见，全力支持你的个人发展。<\/li>\n<\/ul>\n<p>我们相信不只要让产品变得更好，还应该投入时间和心血，让每位成员都变得更好更强。你一定会成长和收获很多。<\/p>\n<p>PS ：目前的技术/工具栈： Node.js / Python / MongoDB / Jieba / PM2 / Responsive Web UI / Bootstrap / Jade / Less / Github / Wercker / Gulp / Mocha / ESLint / Slack / G Suite<\/p>\n<p>PPS ：如果你喜欢喵就更好，我们以后可以在办公室养一只（咦这话好基～）。<\/p>\n<p>附产品截图和办公环境实拍：\n<img src=\"//dn-cnode.qbox.me/FuetTnQ51pC0AvpalVv1E3-5nJAU\" alt=\"首页.jpg\">\n<img src=\"//dn-cnode.qbox.me/Fr_6VjRv5zdW-VR83IVqCCc4Rlum\" alt=\"搜索结果.jpg\">\n<img src=\"//dn-cnode.qbox.me/Fr58kehTbrm7aiZsg5otr9MofJJ9\" alt=\"二维码.jpg\">\n<img src=\"//dn-cnode.qbox.me/Fj874nk1r6DZdVGb6b6fk9DxTJbZ\" alt=\"office-1_1200.jpg\"><\/p>\n<p>做暖房的出发点是我们不相信未来租房是现在这么艰难的，所以决定实际动手做些事情，希望能一点点帮助大家更容易租到好房子。我们以前 hack 产品、技术和设计，现在希望把技术应用到基础生活，尝试 hack 一下社会的运作方式，很挑战也一定会很有意思。<\/p>\n<p>想一起折腾？直接联系创始人冯嘉彬：<\/p>\n<ul>\n<li>邮箱 <a href=\"http://xn--jiabinnuan-lq2ho634t.io\">jiabin⭕️nuan.io<\/a><\/li>\n<li>微信 jiabinf，或二维码：\n<img src=\"//dn-cnode.qbox.me/Fkrr16o_9UQk8B0qLu6Hcf9yPAG6\" alt=\"wechat-2.jpg\">\n请说明来自 CNode 以及附上个人经历、 Github 、过往项目等关键信息，我们会认真拜读 🙂<\/li>\n<\/ul>\n<\/div>","title":"[广州] 暖房 | 求 Web 全栈、数据挖掘大拿 🤖️🚀 一起用技术让租房变得更容易","last_reply_at":"2017-05-13T06:31:43.225Z","good":false,"top":false,"reply_count":3,"visit_count":245,"create_at":"2017-04-24T14:24:13.693Z","author":{"loginname":"jiabinf","avatar_url":"https://avatars3.githubusercontent.com/u/5972237?v=3&s=120"}},{"id":"5900a0d931e8c2bb1c3dce98","author_id":"59009cbf523b9d0956dada73","tab":"job","content":"<div class=\"markdown-text\"><ul>\n<li><strong>公司简介<\/strong>\n长沙奥比纳网络科技有限公司是一家新成立的初创企业，坐落在河西麓谷企业广场，我们主要从事手游棋牌的开发和运营，公司致力于改变现有的游戏圈的现状，为用户提供更好的游戏体验和服务。<\/li>\n<\/ul>\n<p>我们依托于自己的智慧和劳动，创造最大化的价值；\n我们由一群有理想，有野心的年轻人组成的创业团队；\n我们不看学历，我们注重能力和阅历；\n我们希望改变以往的工作状态，不再受困于被动打工；\n我们向往工作自由，但是不失激情和目标；\n我们做事讲求效率；\n我们长期扎根于游戏圈中，希望能做出自己的一番事业！\n如果你对自己有信心，欢迎加我们公司！<\/p>\n<ul>\n<li>\n<p><strong>薪酬福利<\/strong>\n待遇15K-25K，五险一金、年底分红、弹性工作等一系列福利！！！<\/p>\n<\/li>\n<li>\n<p>职位描述：\n1.负责基于Node.js游戏服务器端框架搭建和逻辑开发；\n2.负责具体功能模块的数据结构设计，实现特定游戏系统功能和逻辑功能；<\/p>\n<\/li>\n<li>\n<p>岗位要求：\n1.精通JavaScript语言，具有良好的代码编写习惯；\n2.熟悉2种以上服务器开发语言，熟悉linux系统；\n3.熟悉MongoDB，redis数据库的优先；\n4.熟悉网易pomelo游戏框架的优先；\n5.熟悉MongoDB数据库；\n6.熟悉cocos2d-js；\n7.有良好的学习能力，能快速熟悉新语言或者新框架；\n8.有独立设计算法、解决程序问题的能力；\n9.有棋牌游戏服务器开发经验者优先；\n10.有良好的团队意识，善于与他人沟通合作，熟悉快速开发流程的优先考虑；<\/p>\n<\/li>\n<\/ul>\n<p>工作地点：长沙麓谷企业广场\n联系人：林总\nNUM:18152815851\n微信同步\nQQ：874584802\n或者邮箱至：874584802@qq.com<\/p>\n<\/div>","title":"【长沙长沙】15k-25k + 期权股份 + 各项福利 ~~~ 长沙招noder","last_reply_at":"2017-05-13T06:04:55.356Z","good":false,"top":false,"reply_count":23,"visit_count":476,"create_at":"2017-04-26T13:30:01.474Z","author":{"loginname":"aobina","avatar_url":"https://avatars3.githubusercontent.com/u/27720683?v=3&s=120"}},{"id":"59169e429e32cc84569a6f2e","author_id":"59167ff29e32cc84569a6f2b","tab":"share","content":"<div class=\"markdown-text\"><h1>Ucenter<\/h1>\n<h5><a href=\"https://github.com/mane115/ucenter\">github地址<\/a><\/h5>\n<p>上一年接手了一个开发oauth2的鉴权服务器的项目，基于drywall开发的，但是drywall的工程目录用起来十分不顺手，所以私底下用koa2写了重构了用户中心，支持单账号多app，在这里分享下我的开发心得。\n有事出去一下，就先分享下模型设计和目录结构吧~ ??\n为什么表格显示都是乱的？预览是正常的？<\/p>\n<ul>\n<li>\n<h4>逻辑流程<\/h4>\n<p>留坑<\/p>\n<\/li>\n<li>\n<h4>程序设计<\/h4>\n<p>留坑<\/p>\n<\/li>\n<li>\n<h4>model设计<\/h4>\n<p>模型设计的表格显示都少了一列，等我搞清楚原因再放上来吧，github上面的模型设计是正常的<\/p>\n<\/li>\n<li>\n<h4>工程目录<\/h4>\n<p><img src=\"//dn-cnode.qbox.me/FsWYl1Q1QCrcVPUJie7_gLUFCskN\" alt=\"untitled4.png\"><\/p>\n<ul>\n<li>\n<p>common<\/p>\n<ul>\n<li>const.js 存放静态变量<\/li>\n<li>error.map.js 存放错误码<\/li>\n<\/ul>\n<\/li>\n<li>\n<p>config<\/p>\n<ul>\n<li>config.dev.js 存放开发环境配置<\/li>\n<li>config.workong.js 开发环境配置示例<\/li>\n<li>config.production.js 存放生产环境配置<\/li>\n<li>index.js 根据运行环境返回配置文件<\/li>\n<\/ul>\n<\/li>\n<li>\n<p>controller 业务逻辑存放的文件目录<\/p>\n<\/li>\n<li>\n<p>dao 数据库代理文件夹<\/p>\n<ul>\n<li>mongo 对mongo的数据操作<\/li>\n<li>sql 对sql的数据操作<\/li>\n<li>redis 对redis的数据操作<\/li>\n<\/ul>\n<\/li>\n<li>\n<p>logs 日志文件夹<\/p>\n<\/li>\n<li>\n<p>midware<\/p>\n<ul>\n<li>filter 该文件夹下的文件基于业务分类，封装了每个接口的数据过滤中间件<\/li>\n<li>auth.js 验证中间件，验证token的合法性等用途<\/li>\n<li>log.js 我使用的是使用log4js，所以基于业务配置了不同的appender\n这里放一点代码解释会实际一点<pre class=\"prettyprint language-js\"><code>const log4js = require(&#x27;log4js&#x27;),\n\t  adminLogger = log4js.getLogger(&#x27;admin&#x27;),\n\t  oauthLogger = log4js.getLogger(&#x27;oauth&#x27;),\n\t  commonLogger = log4js.getLogger(&#x27;common&#x27;),\n\t  userLogger = log4js.getLogger(&#x27;user&#x27;);\nvar user = async(ctx, next) =&gt; {\n\t  ctx.logger = userLogger;\n\t  await next()\n};   \n<\/code><\/pre><\/li>\n<\/ul>\n<\/li>\n<li>\n<p>model 数据库model定义<\/p>\n<\/li>\n<li>\n<p>router 路由定义<\/p>\n<\/li>\n<li>\n<p>service 第三方服务等封装，例如我把密码加密，验证放在了这里做成一个服务，token也封装成一个服务，这样以后更改密码加密形式或者token加密形式的时候就可以直接在这里改。<\/p>\n<ul>\n<li>passport.js<pre class=\"prettyprint language-js\"><code>var bcrypt = require(&#x27;bcrypt&#x27;);\nvar Promise = require(&#x27;bluebird&#x27;);\nvar config = require(&#x27;..&#x2F;config&#x27;);\nPromise.promisifyAll(bcrypt);\n&#x2F;**\n * 加盐加密\n * [@param](&#x2F;user&#x2F;param) password {string} 原始密码\n * [@return](&#x2F;user&#x2F;return) hash {object} 加密密码\n * [@author](&#x2F;user&#x2F;author) gh\n *&#x2F;\nvar encrypt = async function(password) {\n    var salt = await bcrypt.genSaltAsync(config.password.saltTimes);\n    var hash = await bcrypt.hashAsync(password, salt);\n    return hash;\n};\n&#x2F;**\n * 密码对比\n * [@param](&#x2F;user&#x2F;param) password {string} 原始密码\n * [@param](&#x2F;user&#x2F;param) hash {string} 加密密码\n * [@return](&#x2F;user&#x2F;return) res {boolean} 比对结果 true:密码匹配 | false:密码不匹配\n * [@author](&#x2F;user&#x2F;author) gh\n *&#x2F;\nvar validate = async function(password, hash) {\n    var res = await bcrypt.compareAsync(password, hash);\n    return res\n};\nmodule.exports = {\n    encrypt,\n    validate\n}\n<\/code><\/pre><\/li>\n<\/ul>\n<\/li>\n<li>\n<p>test 测试用例文件夹<\/p>\n<\/li>\n<li>\n<p>util 工具类的封装<\/p>\n<\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<\/div>","title":"基于koa2开发的一个用户中心","last_reply_at":"2017-05-13T05:48:50.902Z","good":false,"top":false,"reply_count":0,"visit_count":174,"create_at":"2017-05-13T05:48:50.902Z","author":{"loginname":"mane115","avatar_url":"https://avatars1.githubusercontent.com/u/14268652?v=3&s=120"}},{"id":"59167788ba8670562a40f088","author_id":"57957de04265959826e7b25b","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>刚学习mongodb做demo，查了一下mongodb默认没开启认证功能，导致我数据库被别人清空！<\/strong>\n在此我想了解一下mongodb如何开启认证功能，就是每次连接数据库都需要帐号密码！\n<img src=\"//dn-cnode.qbox.me/FjT5OUniiz82A3awaFC7IsYlnC8y\" alt=\"1.png\">\n<img src=\"//dn-cnode.qbox.me/FjW_tOgGjhPf-6SdNhM6xBnH2M0h\" alt=\"2.png\">\n在此感谢CNode的各位大佬回答，手动递茶！<\/p>\n<\/div>","title":"问下mongodb认证问题","last_reply_at":"2017-05-13T05:36:05.859Z","good":false,"top":false,"reply_count":3,"visit_count":107,"create_at":"2017-05-13T03:03:36.514Z","author":{"loginname":"zhang962976642","avatar_url":"https://avatars2.githubusercontent.com/u/16224118?v=3&s=120"}},{"id":"59142ef63504ce1c2ac45adb","author_id":"59142c02d371b6372a8af811","tab":"ask","content":"<div class=\"markdown-text\"><p>使用express写了后端api(监听的是3000端口),在主机上使用pm2启动并watch服务(监听3000端口),使用Nginx做服务器，并做端口转发,页面和接口都没问题。可是，随着时间的推移，过了几个小时，页面就会报以下错：\n<img src=\"//dn-cnode.qbox.me/FuAruE7NlXUxixUS6nJpEL4-v_1A\" alt=\"1494493881(1).jpg\">\n我以为是服务挂了，可是：\n![<a href=\"//dn-cnode.qbox.me/Fq90M8gt-3TMqnCdrgrKIySMPApT\">5%GF93U%N13K)ROD(3XNWB.png<\/a>\n看了下,3000端口,处于监听状态，然后pm2也是好着。但是，我重启下pm2，就又恢复正常了，也不会报错了,过那么几个小时，又是504错误。。。大神们，help me。<\/p>\n<p>这里贴上我的Nginx关键的配置，不知道，是Nginx配置问题，还是pm2的问题，还是我的代码自身的问题。\n<img src=\"//dn-cnode.qbox.me/FhseUba_6rDHOuhJBvQZHaG2Eng6\" alt=\"1494493754(1).jpg\"><\/p>\n<\/div>","title":"使用pm2守护node进程，过几个小时就会出现504错误。","last_reply_at":"2017-05-13T04:58:19.539Z","good":false,"top":false,"reply_count":14,"visit_count":378,"create_at":"2017-05-11T09:29:26.946Z","author":{"loginname":"alloyteamzy","avatar_url":"https://avatars1.githubusercontent.com/u/13064522?v=3&s=120"}},{"id":"590371a693aa348e3d40e70b","author_id":"5902cd88782dbc4b183eceda","tab":"job","content":"<div class=\"markdown-text\"><p>教育方向，中小学K12线上线下智能学习平台<\/p>\n<p><strong>团队价值观<\/strong>\n保持专注、持续交付！\n你若有才，就赶紧来！我们拒绝平庸！<\/p>\n<p>官网：<a href=\"http://www.gankao.com\">www.gankao.com<\/a>\nApp： <a href=\"http://www.gankao.com/app\">《赶考网校》<\/a><\/p>\n<p><strong>职位描述：<\/strong>\n1、配合产品经理，根据产品原型和文档完成开发；\n2、参与架构的讨论与设计\n3、帮带实习生\\编写必要的开发注释文档(自动化)\n4、研究新技术方向<\/p>\n<p><strong>任职要求：<\/strong>\n1、至少1年以上nodejs全栈开发经验，至少2款产品迭代经验\n2、熟悉HTML5/Javascript/CSS3等基础领域，熟悉BootStrip/WEUI/MUI等CSS框架\n3、熟悉React/ReactRouter/Redux/ES6deJS/Express/MySql/MongoDB/Redis技术栈\n4、具备独立的MySql/MongoDB数据库策划设计能力\n5、有Sequelize ORM框架使用经验的优先录用\n6、有参与Scrum敏捷研发经验的优先录用\n7、良好的团队意识和协作精神，有较强的沟通表达能力。\n8、熟悉elk数据可视化领域的优先\n9、有微服务经验者优先<\/p>\n<p><strong>福利：<\/strong>\n1、五险一金、年休假、餐补、旅游等\n2、公司可提供住宿<\/p>\n<p>** 待遇：**\n\t12 - 20k<\/p>\n<p>** 联系方式：**\n\t微信：139-1892-5582 (手机号)\n\t邮箱：89479759@qq.com\n\t拉勾上投递简历：<a href=\"https://www.lagou.com/jobs/2714114.html\">https://www.lagou.com/jobs/2714114.html<\/a><\/p>\n<p><strong>工作地址：<\/strong>\n上海上海松江区 三新北路900弄（泰晤士小镇）<\/p>\n<p>推荐成功有奖哦：1000元<\/p>\n<\/div>","title":"【上海松江】Nodejs中/高级全栈招聘-教育方向／赶考网校","last_reply_at":"2017-05-13T04:54:24.955Z","good":false,"top":false,"reply_count":1,"visit_count":175,"create_at":"2017-04-28T16:45:26.292Z","author":{"loginname":"threem0126","avatar_url":"https://avatars3.githubusercontent.com/u/5511360?v=3&s=120"}},{"id":"590ce994d371b6372a8af601","author_id":"57d216e13d3520a5387c2b53","tab":"ask","content":"<div class=\"markdown-text\"><p>命令窗口中显示找不到<img src=\"//dn-cnode.qbox.me/FqpkJ4Pi0v1ynwDoR4TXesHskiRb\" alt=\"1.png\">\napp.js <img src=\"//dn-cnode.qbox.me/FmyIXwSCldWJ_ZTSfwPaLuzmKXWt\" alt=\"4.png\"><\/p>\n<p>路由层<img src=\"//dn-cnode.qbox.me/Fml2QjXSWZRmDLks2FOeplL3YnTz\" alt=\"2.png\"><\/p>\n<p>控制器层<img src=\"//dn-cnode.qbox.me/FphaigVKjnCeQh6AaCtSeW4dkmq0\" alt=\"3.png\"><\/p>\n<p>请求页面在的目录<img src=\"//dn-cnode.qbox.me/FmyjPOh1neqvFjqPXEkRkJBU-DMT\" alt=\"5.png\"><\/p>\n<\/div>","title":"大家好 谁能帮我看一眼 为什么总是提示找不到页面","last_reply_at":"2017-05-13T04:26:33.713Z","good":false,"top":false,"reply_count":19,"visit_count":546,"create_at":"2017-05-05T21:07:32.133Z","author":{"loginname":"a69694510","avatar_url":"https://avatars2.githubusercontent.com/u/20507053?v=3&s=120"}},{"id":"586760485eac96bb04d3e2f3","author_id":"5280376ed2b3893f2a4a4f6a","tab":"ask","content":"<div class=\"markdown-text\"><p>需求是依次请求三个URL，并把请求结果依次输出\n<a href=\"http://baidu.com/a.html\">http://baidu.com/a.html<\/a>\n<a href=\"http://baidu.com/b.html\">http://baidu.com/b.html<\/a>\n<a href=\"http://baidu.com/c.html\">http://baidu.com/c.html<\/a><\/p>\n<\/div>","title":"谁能帮我用promise写一个例子？需求是依次请求三个URL，并把请求结果依次输出","last_reply_at":"2017-05-13T04:12:15.616Z","good":false,"top":false,"reply_count":4,"visit_count":676,"create_at":"2016-12-31T07:37:44.420Z","author":{"loginname":"zhishaofei3","avatar_url":"https://avatars2.githubusercontent.com/u/2910585?v=3&s=120"}},{"id":"591130d6ba8670562a40ee44","author_id":"59101cdcd371b6372a8af6a9","tab":"ask","content":"<div class=\"markdown-text\"><p>只是一个js小白，在做一个程序的时候总是想到要连接后台跟数据库，想到PHP麻烦就找到了node.js.<\/p>\n<p>怎样继续学下去啊。好迷茫。<\/p>\n<\/div>","title":"从深入浅出Node.js中入门可以吗？","last_reply_at":"2017-05-13T03:30:23.269Z","good":false,"top":false,"reply_count":11,"visit_count":559,"create_at":"2017-05-09T03:00:38.080Z","author":{"loginname":"gregLINm","avatar_url":"https://avatars3.githubusercontent.com/u/26732117?v=3&s=120"}},{"id":"591661ac9e32cc84569a6f20","author_id":"585eae74708f21aa5db0ecc4","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FjwxDjgCwfEraMcRXKIgJMT13Ryt\" alt=\"微信图片_20170513092740.jpg\">我数据库里的title就是获取不到<img src=\"//dn-cnode.qbox.me/FplwiDRBTadVp-tmAARz9_8JeF_R\" alt=\"微信图片_20170513092731.jpg\">求大神指点<\/p>\n<\/div>","title":"织梦cms为什么获取不到有些字段呢？","last_reply_at":"2017-05-13T03:14:53.578Z","good":false,"top":false,"reply_count":4,"visit_count":128,"create_at":"2017-05-13T01:30:20.626Z","author":{"loginname":"qiphon","avatar_url":"https://avatars1.githubusercontent.com/u/24565078?v=3&s=120"}},{"id":"59142cfb9e32cc84569a6dbc","author_id":"59142c02d371b6372a8af811","tab":"ask","content":"<div class=\"markdown-text\"><p>使用express写了后端api(监听的是3000端口),在主机上使用pm2启动并watch服务(监听3000端口),使用Nginx做服务器，并做端口转发,页面和接口都没问题。可是，随着时间的推移，过了几个小时，页面就会报以下错：\n我以为是服务挂了，可是：\n看了下,3000端口,处于监听状态，然后pm2也是好着。但是，我重启下pm2，就又恢复正常了，也不会报错了,过那么几个小时，又是504错误。。。大神们，help me。<\/p>\n<p>这里贴上我的Nginx关键的配置，不知道，是Nginx配置问题，还是pm2的问题，还是我的代码自身的问题。<\/p>\n<\/div>","title":"使用pm2守护node进程，过几个小时就会出现504错误。","last_reply_at":"2017-05-13T02:48:20.419Z","good":false,"top":false,"reply_count":3,"visit_count":212,"create_at":"2017-05-11T09:20:59.118Z","author":{"loginname":"alloyteamzy","avatar_url":"https://avatars1.githubusercontent.com/u/13064522?v=3&s=120"}}]
     */

    private boolean success;
    private List<DataBean> data;

    public boolean isSuccess() {
        return success;
    }

    public void setSuccess(boolean success) {
        this.success = success;
    }

    public List<DataBean> getData() {
        return data;
    }

    public void setData(List<DataBean> data) {
        this.data = data;
    }

    public static class DataBean {
        /**
         * id : 58d0fb3517f61387400b7e15
         * author_id : 4f447c2f0a8abae26e01b27d
         * tab : share
         * content : <div class="markdown-text"><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/1ac00bee5abd7cc1d9a9435f861acba6.png" alt="screenshot.png"></p>
         <blockquote>
         <p>原文地址：<a href="https://zhuanlan.zhihu.com/p/25860846">https://zhuanlan.zhihu.com/p/25860846</a></p>
         </blockquote>
         <hr>
         <p>时光如梭，转眼间 Egg.js 已经开源半年了，我们很荣幸地宣布，Egg.js 正式发布 1.0 版本。</p>
         <ul>
         <li>官网传送门：<a href="https://eggjs.org">https://eggjs.org</a></li>
         <li>GitHub：<a href="https://github.com/eggjs/egg">https://github.com/eggjs/egg</a></li>
         <li>Egg.js 英文文档：与 SwiftGG 翻译组强强联合，中译英的小伙伴招募中，如果你有兴趣，请试译 这篇文章 ，并注明你的 qq 号，发送给 SwiftGG 的同学邮箱(<a href="mailto:1030041592@qq.com">1030041592@qq.com</a>)。期待你的加入！</li>
         </ul>
         <h2>特点</h2>
         <ul>
         <li><strong>『企业级的 Node.js Web 基础框架』</strong>，寓意 - 孕育新生。</li>
         <li>业界领先的 <strong>『微内核 + 插件机制』</strong>，专为团队架构师量身打造的 <strong>『框架定制』</strong> 能力。</li>
         <li>内建的安全机制与多进程管理模型。</li>
         <li>高可用，高质量，严格遵循 Semver 规则，测试覆盖率 100%（travis/appveyor)。</li>
         <li>同时支持 koa 1.x 和 2.x 生态，支持 ES 2017 Async Await。</li>
         <li>沉淀自阿里各行各业不同领域最佳实践的插件，涵盖了常见的业务开发场景，稳定支撑了 15 和 16 年天猫双11大促，顶级流量压力。</li>
         <li>渐进式，极具伸缩性，既适合个人小项目快速开发，也适合企业级的团队开发协作。</li>
         </ul>
         <blockquote>
         <p>更详细的特点，以及 Node.js 在阿里的定位，可以参见： <a href="https://www.zhihu.com/question/50526101/answer/144952130">如何评价阿里开源的企业级 Node.js 框架 egg？</a></p>
         </blockquote>
         <h2>里程碑</h2>
         <ul>
         <li>2013 年蚂蚁的 chair 框架，可视为 Egg.js 前身。</li>
         <li>2015 年 11 月，在苏千的召集下，阿里各 BU 的前端骨干齐聚黄龙，闭门共建一周。</li>
         <li>2016 年初，各 BU 的基础 Web 框架完成升级，在同一套规范的基础上进行差异化定制。</li>
         <li>2016 年中，成为阿里 Node.js 基建，广泛使用在绝大部分阿里的前端 Node.js 应用。</li>
         <li>2016 年 09 月，在 <a href="http://2016.jsconf.cn/">JSConf China 2016</a> 上亮相并宣布开源。</li>
         <li>2017 年初，经过一周的<a href="https://cnodejs.org/topic/5870e9da04dcf9a706a745f0">闭关直播写文档</a>，期待已久的 <a href="https://eggjs.org/">官方文档</a> 诚意登场，足足近 30 篇。</li>
         <li>2017年 02 月，知乎问答：<a href="https://www.zhihu.com/question/50526101/answer/144952130">如何评价阿里开源的企业级 Node.js 框架 egg？</a></li>
         <li>2017 年 02 月第 2 周，上了 <strong>GitHub Trending</strong> 周榜第三，Star 数增加 1k 多。</li>
         <li>2017 年 03 月 21 日，Egg.js 正式发布 1.0.0 。</li>
         </ul>
         <h2>成就</h2>
         <ul>
         <li>截止到今天，2250+ Star，50+ 插件，10+ 核心开发者，30+ 贡献者。</li>
         <li>GitHub Trending 周榜第三，并上了 Node Weekly 周刊。</li>
         <li>官网 UV 日均 300+ 。</li>
         </ul>
         <p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2a69766ae55cab517418e7b2f004d9b9.png" alt="screenshot.png"></p>
         <ul>
         <li>Node TSC Director - Rod Vagg 在 Twitter 上关注并转发。</li>
         </ul>
         <p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/42f3483f8c7b9a39678958816f477ae2.png" alt="screenshot.png"></p>
         <h2>感言</h2>
         <p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6461618ea8944a1fb5ada1db8aeb7de7.png" alt="screenshot.png"></p>
         <h2>规划</h2>
         <ul>
         <li>Egg.js 英文文档翻译，欢迎加入 <a href="http://swift.gg/">SwiftGG 翻译组</a> 发起的 <a href="https://github.com/eggjs/egg/issues/363">Egg 文档翻译项目</a>。</li>
         <li>继续完善文档，沉淀最佳实践，并帮助社区产出更多的插件和上层框架。</li>
         <li>Node.js 8 LTS 发布后，底层将无缝升级到 Koa<a href="/user/2">@2</a> 。</li>
         </ul>
         </div>
         * title : Egg.js 1.0.0 正式发布 - 企业级 Node.js 框架
         * last_reply_at : 2017-05-13T15:29:10.915Z
         * good : false
         * top : true
         * reply_count : 135
         * visit_count : 24361
         * create_at : 2017-03-21T10:06:45.487Z
         * author : {"loginname":"atian25","avatar_url":"https://avatars.githubusercontent.com/u/227713?v=3&s=120"}
         */

        private String id;
        private String author_id;
        private String tab;
        private String content;
        private String title;
        private String last_reply_at;
        private boolean good;
        private boolean top;
        private int reply_count;
        private int visit_count;
        private String create_at;
        private AuthorBean author;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getAuthor_id() {
            return author_id;
        }

        public void setAuthor_id(String author_id) {
            this.author_id = author_id;
        }

        public String getTab() {
            return tab;
        }

        public void setTab(String tab) {
            this.tab = tab;
        }

        public String getContent() {
            return content;
        }

        public void setContent(String content) {
            this.content = content;
        }

        public String getTitle() {
            return title;
        }

        public void setTitle(String title) {
            this.title = title;
        }

        public String getLast_reply_at() {
            return last_reply_at;
        }

        public void setLast_reply_at(String last_reply_at) {
            this.last_reply_at = last_reply_at;
        }

        public boolean isGood() {
            return good;
        }

        public void setGood(boolean good) {
            this.good = good;
        }

        public boolean isTop() {
            return top;
        }

        public void setTop(boolean top) {
            this.top = top;
        }

        public int getReply_count() {
            return reply_count;
        }

        public void setReply_count(int reply_count) {
            this.reply_count = reply_count;
        }

        public int getVisit_count() {
            return visit_count;
        }

        public void setVisit_count(int visit_count) {
            this.visit_count = visit_count;
        }

        public String getCreate_at() {
            return create_at;
        }

        public void setCreate_at(String create_at) {
            this.create_at = create_at;
        }

        public AuthorBean getAuthor() {
            return author;
        }

        public void setAuthor(AuthorBean author) {
            this.author = author;
        }

        public static class AuthorBean {
            /**
             * loginname : atian25
             * avatar_url : https://avatars.githubusercontent.com/u/227713?v=3&s=120
             */

            private String loginname;
            private String avatar_url;

            public String getLoginname() {
                return loginname;
            }

            public void setLoginname(String loginname) {
                this.loginname = loginname;
            }

            public String getAvatar_url() {
                return avatar_url;
            }

            public void setAvatar_url(String avatar_url) {
                this.avatar_url = avatar_url;
            }
        }
    }
}
